{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/header.jpg","path":"images/header.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/clicklove.js","path":"js/src/clicklove.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/LICENSE","path":"lib/canvas-nest/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/README.md","path":"lib/canvas-nest/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest-nomobile.min.js","path":"lib/canvas-nest/canvas-nest-nomobile.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1590051798468},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1590051798469},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1590051798471},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1590051798469},{"_id":"source/.DS_Store","hash":"98fda64f29313934c6c80856e2f900a5647d0579","modified":1590049966957},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1590051798471},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1590051798471},{"_id":"themes/next/_config.yml","hash":"57191a778637f2d19a2a61a22f1e001254410f29","modified":1590561862097},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1590051798472},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1590051798471},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1590051798472},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1590051798476},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1590051798488},{"_id":"source/_posts/react-04.md","hash":"39138aebede9ad337eec7894495c3354957b38be","modified":1590562244505},{"_id":"source/_posts/react-01.md","hash":"544f998b06887dda1110aa0fee3e0d38f3a5a1f1","modified":1590562227561},{"_id":"source/_posts/react-03.md","hash":"819784eb5a904bd1b114b9c938e13ca91b66274d","modified":1590562241680},{"_id":"source/_posts/react-02.md","hash":"801ff3909dd07fbcec819eb3bef7d7300bd30a65","modified":1590562234907},{"_id":"source/_posts/react-06.md","hash":"9bda049bac5dd7a2fa9496a27b2c806ace5f10d1","modified":1590563702538},{"_id":"source/_posts/react-09.md","hash":"89456e7ff6ed30f93d60c40e3264cf0b692b6151","modified":1590568971166},{"_id":"source/_posts/react-07.md","hash":"67ca5d3b947cf706c1279217be609a5191b1429a","modified":1590567580698},{"_id":"source/_posts/react-05.md","hash":"ea6f5a58794cca203dbb594b68b907212ab7c508","modified":1590563077202},{"_id":"source/_posts/react-08.md","hash":"8f2c519be3bc36f3fb808d73730286bf7667ca09","modified":1590568414507},{"_id":"source/_posts/react-10.md","hash":"602578c5717e28360c16eeede736c8918431eef8","modified":1590815632657},{"_id":"source/_posts/react-11.md","hash":"6f770af807ba35b2e5490c0cc968c553570c759e","modified":1590816674542},{"_id":"source/_posts/react-12.md","hash":"90319a0b072123f9f72b61b64db110915c213db4","modified":1590817425178},{"_id":"source/_posts/react-16.md","hash":"67d13ec42a3a5c9e1c580ebbd464ed58a5244932","modified":1591004418524},{"_id":"source/_posts/react-17.md","hash":"0988d29e8fa6709be30426fc0adb5a6fa85e5aaf","modified":1593331844243},{"_id":"source/_posts/react-18.md","hash":"38e5ef21b9ac0fd5bfbf0575cb65dd7374149bcc","modified":1593334069734},{"_id":"source/categories/index.md","hash":"e9b3eb49eb72694e973f4222d67d1a9a5aa29bbc","modified":1590375213446},{"_id":"source/react/index.md","hash":"8e10cfaa23e56cf2ddb8c0d78aac56cfff822634","modified":1593334232338},{"_id":"source/_posts/react-13.md","hash":"4ee25fbb2bdf43041bcd261114f3c2ba7bf379e3","modified":1590817768662},{"_id":"source/_posts/react-14.md","hash":"00b01c33d56331115560caee97863e602bd730c7","modified":1590819227681},{"_id":"source/_posts/react-15.md","hash":"50bccdd0a850fa1a8276ff230286215137f1e109","modified":1591002147223},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1590051798469},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1590051798469},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1590051798470},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1590051798470},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1590051798470},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1590051798470},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1590051798470},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1590051798471},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1590051798471},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1590051798471},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1590051798471},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1590051798473},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1590051798473},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1590051798473},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1590051798473},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1590051798473},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1590051798473},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1590051798474},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1590051798474},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1590051798476},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1590314295355},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1590051798476},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1590051798477},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1590051798477},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1590051798477},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1590051798477},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1590314295355},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1590051798477},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1590051798477},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1590051798478},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1590051798477},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1590051798477},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1590051798478},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1590051798478},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1590051798478},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1590051798478},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1590051798478},{"_id":"themes/next/languages/zh-CN.yml","hash":"4edccfdb7e2021bb1604952ef36db6892952129c","modified":1590561726328},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1590051798479},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1590051798479},{"_id":"themes/next/layout/_layout.swig","hash":"d2f9cd0401e16dc59310645b24be66daa5eefeaf","modified":1590559292102},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1590051798487},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1590051798487},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1590051798487},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1590051798487},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1590051798478},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1590051798488},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1590051798488},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1590051798491},{"_id":"themes/next/source/.DS_Store","hash":"2b4f0d7bc2c38cceed4e5588284e6014e21c1219","modified":1590476280889},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1590051798472},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1590051798469},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1590051798470},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1590051798470},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1590051798470},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1590051798474},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1590051798474},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1590051798474},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1590051798475},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1590051798475},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1590051798474},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1590051798475},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1590051798475},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1590051798476},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1590051798475},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1590051798475},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1590051798476},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1590051798476},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1590051798479},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1590051798479},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1590051798479},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1590051798479},{"_id":"themes/next/layout/_partials/footer.swig","hash":"00333a9869eefa04e7327048efea5b375a2f3b85","modified":1590231679928},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1590051798481},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1590051798481},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1590051798482},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1590051798482},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1590051798482},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1590051798483},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1590051798483},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1590051798483},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1590051798484},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1590051798485},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1590051798486},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1590051798486},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1590051798488},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1590051798490},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1590051798490},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1590051798490},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1590051798490},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1590051798490},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1590051798490},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1590051798490},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1590051798491},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1590051798491},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1590051798491},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1590051798491},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1590051798491},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1590051798491},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1590051798491},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1590051798491},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1590051798492},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1590051798492},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1590051798492},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1590051798492},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1590051798492},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1590051798502},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1590051798505},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1590051798505},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1590051798505},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1590051798505},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1590051798505},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1590051798505},{"_id":"themes/next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1590476894496},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1590051798506},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1590051798506},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1590051798506},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1590051798506},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1590051798506},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1590051798506},{"_id":"themes/next/source/images/header.jpg","hash":"1c2c8ebbc155937aa47d1763b3773bb383634ace","modified":1590233104687},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1590051798506},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1590051798507},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1590051798507},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1590051798507},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1590051798507},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1590051798507},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1590051798507},{"_id":"themes/next/source/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1590051798508},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1590051798509},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1590051798480},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1590051798480},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1590051798480},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1590051798480},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1590051798480},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1590051798480},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1590051798480},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1590051798481},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1590051798481},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1590051798481},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1590051798481},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1590051798481},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1590051798481},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1590051798482},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1590051798482},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1590051798482},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1590051798482},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1590051798482},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1590051798483},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1590051798483},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1590051798483},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1590051798483},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1590051798483},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1590051798484},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1590051798484},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1590051798484},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1590051798484},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1590051798484},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1590051798484},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1590051798484},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1590051798485},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1590051798485},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1590051798485},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1590051798485},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1590051798485},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1590051798485},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1590051798485},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1590051798485},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1590051798486},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1590051798486},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1590051798486},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1590051798486},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1590051798486},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1590051798486},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1590051798487},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1590051798487},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1590051798487},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1590051798487},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1590051798488},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1590051798488},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1590051798488},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1590051798489},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1590051798489},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1590051798489},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1590051798489},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1590051798489},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1590051798489},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1590051798489},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1590051798489},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1590051798504},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1590051798505},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1590051798504},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1590051798504},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1590051798504},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1590051798508},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1590051798508},{"_id":"themes/next/source/js/src/clicklove.js","hash":"effa770d8085f7e7fb903de217ce521dff163780","modified":1590559258850},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1590560956345},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1590051798511},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1590051798512},{"_id":"themes/next/source/lib/canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1590560956344},{"_id":"themes/next/source/lib/canvas-nest/README.md","hash":"0ba5a24a483f36166f0cb871bd30f4c7467f3593","modified":1590560956344},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"956eada198babd00f028e8908767cb158926c3f3","modified":1590560956344},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1590051798492},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1590051798493},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1590051798492},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1590051798497},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1590051798495},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1590051798499},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1590051798499},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1590051798500},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1590051798497},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1590051798500},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1590051798500},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1590051798500},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1590051798501},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1590051798502},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1590051798502},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1590051798502},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1590051798503},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1590051798502},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1590051798502},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1590051798502},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1590051798503},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1590051798503},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1590051798503},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1590051798503},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1590051798503},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1590051798503},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1590051798504},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1590051798504},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1590051798504},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1590051798504},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1590051798503},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1590051798503},{"_id":"themes/next/source/lib/canvas-nest/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1590560956343},{"_id":"themes/next/source/lib/canvas-nest/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1590560956337},{"_id":"themes/next/source/lib/canvas-nest/.git/config","hash":"6aef6bbfcb8ccf9d042bf26defe7d08167b6d81e","modified":1590560956339},{"_id":"themes/next/source/lib/canvas-nest/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1590560953791},{"_id":"themes/next/source/lib/canvas-nest/.git/index","hash":"24573930935ced0e3451be31c5e4560ea6e4125e","modified":1590560956346},{"_id":"themes/next/source/lib/canvas-nest/.git/packed-refs","hash":"80eecf0c5c7f21b2678dc1c329f74de19b6a3a67","modified":1590560956335},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1590051798510},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1590051798511},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1590051798509},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1590051798510},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1590051798493},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1590051798493},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1590051798493},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1590051798493},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1590051798493},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1590051798493},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1590051798494},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1590561311150},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1590051798494},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1590051798494},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1590051798494},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1590051798494},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1590051798494},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1590051798495},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1590051798495},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"71110fc84904314f985a2729a1e841120c3a25f5","modified":1590565468752},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1590051798494},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1590051798494},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1590051798495},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1590051798495},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1590051798496},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1590051798495},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1590051798496},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1590051798497},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1590051798497},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1590051798496},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1590051798497},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1590051798497},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1590051798496},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1590051798497},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1590051798497},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1590051798498},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1590051798498},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1590051798498},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1590051798498},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1590051798498},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1590051798499},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1590051798499},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1590051798499},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1590051798499},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1590051798499},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1590051798500},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1590051798500},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1590051798500},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1590051798500},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1590051798501},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1590051798501},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1590051798501},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1590051798501},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1590051798501},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1590051798501},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1590051798501},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1590560953792},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1590560953793},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1590560953795},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1590560953794},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1590560953793},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1590560953795},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1590560953794},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1590560953796},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1590560953793},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1590560953795},{"_id":"themes/next/source/lib/canvas-nest/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1590560953791},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/HEAD","hash":"9c3bbb1b828c3c4e034afd0a52699c85d982b03a","modified":1590560956338},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1590560953796},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1590560956248},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/22/504fa21ce1b75e3f898ffafc8d2a8bed8d00c9","hash":"7c6ee7a38812c72e52ecb5c2ad725a9f103923a6","modified":1590560956321},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/17/9eb5d6cd5f44ba3dd9e08b4ffcd83bb26db80a","hash":"03d593c92c9fad045d298f58afdbbcfbde923999","modified":1590560956247},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1590560956248},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/2a/f622a4d7df40a2708946e91d6d7a0df1dc468c","hash":"3da7207fb18d361b83c56f4e35f67e9e945abd82","modified":1590560956258},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/45/9262fe92f0115707bf8d8764f1886bc5e7c9e0","hash":"36040483f8af76775b7e4b6d87cec53729625399","modified":1590560956259},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/44/6ddf9b6c0e5ade17ca5cb99f9b3a5300919c57","hash":"fb72799ff98445f72fda041337da4cf105d9dcba","modified":1590560956252},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/46/cad4f872aa93e813aed99547c4705322ca483f","hash":"b0465d3186e2d58a8a99c56c6e68aa2965a396d4","modified":1590560956242},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/51/7c5eb7dcc2cb9769efea2e7375ff6e04123150","hash":"ec53157077d47430f4729bf164999d18d370aeab","modified":1590560956255},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/4b/2975337cf280e5555ca7a82dc7c2d4b437c5b0","hash":"d36f2c2b52c48d7f7cd0d0beb42be2ecd7534287","modified":1590560956260},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/50/306daa49b7b24c4759a4e832bfba3531c53f49","hash":"32aa9d96315007f8d79cd162bc77398addfa6ddf","modified":1590560956323},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/50/dd2a6539498a70226c81a587db486b47e839ff","hash":"3844b0c815d0b4b32c6312c751a826bf9dc2c945","modified":1590560956243},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/5a/69ce9c2e4a1a34f6063ae9a121af1555669c69","hash":"dad25cc0f450e2827b5676975f4a70636e3fd2c8","modified":1590560956250},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/5e/8ae972c99b04af7dd56dabfc485e8fdae5094d","hash":"791b3349c5696ccacae00bffbdbb8d88a03e61a9","modified":1590560956244},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/69/39233ece53c9bdb9a1faf3271ed5768b034aad","hash":"5a770d418c1bb7b0f031f4d5416530002032fcf3","modified":1590560956251},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/69/a20d65d83035fdb01734a8eabe3340f740a4cb","hash":"9e95b02d8e43ec92e06bee3f60dffb74e8e7b9fa","modified":1590560956249},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/75/de2b8fa62d52690de32c351c63ab6446104ed5","hash":"52d10122d633ce4895a0690c5955e1b356f5a391","modified":1590560956259},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/86/1c9f4241fe0eb6af02ad770d5ce04c1f68972b","hash":"7005c3e36015a4af30d4b91bd5a849a7861a073e","modified":1590560956258},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/7b/c7e3186212b6f2e06d3370502565e2c6326890","hash":"379f3c6486f589fc9c1ab07d0382adacf4f655a2","modified":1590560956245},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/8b/66994be5014f18d17347ff32232c91d51ad08c","hash":"a22da1680018e1ab95118216eb88115d2947930a","modified":1590560956325},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/8c/150fefb741be4edee07810003c8a845113e209","hash":"067de29d5efa0a46cdc8f9f113820e5e09bfa50a","modified":1590560956326},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/91/f99a0c53b26dd54f56b9e452c68f56b06f8f7e","hash":"3dca8a5629e66599b6e0f146aa32f1b7ce023d89","modified":1590560956257},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/90/f6477118d05f5f96ce0a63c6f18b7b2baea200","hash":"385f58e92981f27fa54eb52bf60424e87c70a9d8","modified":1590560956247},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/98/67d1132e0e50bbb7df754a63358d70741df6d5","hash":"3cb710a1faee73c08036f5e2df7df3a7ce29e9dd","modified":1590560956245},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/99/be66a33ab4ebc34f62f2880a0e0cc6d334d0f2","hash":"f2346fe8ddd7d7abf38f2946f3083d8150f502d2","modified":1590560956254},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/ab/45cbef9bc70ceff60f1ed52f2a5c34f6ad5725","hash":"ee2fa8f3df0de9092a4fce015cefd76ea18f4cfd","modified":1590560956325},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/aa/da83ad9aa55faa2b34ede31b1d41e16966f80b","hash":"b304541ab95b7969a63ba2ec4f60f5391bd8bb44","modified":1590560956246},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/b1/bb278ca2e50dff1b343f9d5ca025272859432f","hash":"74f0afa72a30268d84613fb0d1d893bba866f01d","modified":1590560956256},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/b3/5fc481f71dd08037f6b9febb5ec02c790f843b","hash":"ed5aa3a748675544aaa141c182a317453dd1e774","modified":1590560956323},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/bb/5755c22b6c1b7461319624f0f000bc947882ee","hash":"2b87a2a354a0fa77cbddf461b03b0b8e43c16a4f","modified":1590560956253},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/ca/3466a8cbf05c2982c58199d6ee71ec6d0271ca","hash":"a9b80b5d827b5e84229b1afd7920d9218dce610f","modified":1590560956254},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/d1/b8c85241243a80f16d56e7a50244d3695f6e6e","hash":"baf56a83286c72af11667786dc59e7c58d30e427","modified":1590560956322},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/d4/95d28a8fab74d23908f6ccef9e4db2625fbacb","hash":"59e6067b0a806deee7bda6460b36c0f63e2e1db5","modified":1590560956256},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/d6/5de52977302632417c21e015956fb3dab8cabd","hash":"e0c8f0483b20434e63748a649ca4afbb417997f4","modified":1590560956251},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/e1/5c0793114874195462829db04d021face6640e","hash":"ff6c6d9f05b171ba67b44564ae3574d16eae6222","modified":1590560956242},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/fd/3e2cc9301ef9c1978ace2bd0aee99f47176661","hash":"09b27ad6cf69d4dcb926389e16913daccb5d2972","modified":1590560956324},{"_id":"themes/next/source/lib/canvas-nest/.git/refs/heads/master","hash":"473e30291eac5f6d120dfe823b29ad4b2218f05a","modified":1590560956338},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/refs/heads/master","hash":"9c3bbb1b828c3c4e034afd0a52699c85d982b03a","modified":1590560956338},{"_id":"themes/next/source/lib/canvas-nest/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1590560956337},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/refs/remotes/origin/HEAD","hash":"9c3bbb1b828c3c4e034afd0a52699c85d982b03a","modified":1590560956337},{"_id":"public/categories/index.html","hash":"5e47f0589478483564f3b83687025fb16409f49c","modified":1593335020264},{"_id":"public/react/index.html","hash":"eca20279f774af1996414b5735c8917e3a58852b","modified":1593335020264},{"_id":"public/2020/06/28/react-18/index.html","hash":"e950f4d8e787927328e529485a93523230979c37","modified":1593335020264},{"_id":"public/2020/06/28/react-17/index.html","hash":"931a21588a9bc6c1cf3fe940f94e33aa4c183bcb","modified":1593335020264},{"_id":"public/2020/05/30/react-13/index.html","hash":"4c6262d74534fc577e511855bef24b85849e0001","modified":1593335020264},{"_id":"public/2020/05/30/react-12/index.html","hash":"eec7d9013318eff7315de75f97f85a8d6fff42f0","modified":1593335020264},{"_id":"public/2020/05/30/react-10/index.html","hash":"ab6600e9f6f67d346faaa6667237fb8205543e5a","modified":1593335020264},{"_id":"public/2020/05/26/react-04/index.html","hash":"d45fcb4bb2ebb10c3167a18f9cc6d22953c3966f","modified":1593335020264},{"_id":"public/2020/05/26/react-03/index.html","hash":"70a45a7a1d1c6c4a585aebdf2b36e7600b85a8d5","modified":1593335020264},{"_id":"public/2020/05/26/react-02/index.html","hash":"c9163e91f6deae8e70d7f056af44f5a9ac7a05f5","modified":1593335020264},{"_id":"public/2020/05/26/react-01/index.html","hash":"c90e3055c043af3213ed62ebb2aeeb178ab0e708","modified":1593335020264},{"_id":"public/archives/index.html","hash":"671e8d8e7b32145cfb69b5bc4161be5646310f22","modified":1593335020264},{"_id":"public/archives/page/2/index.html","hash":"5f3a48897bcb130d75fa62a4c5724c01f9a1c794","modified":1593335020264},{"_id":"public/archives/2020/page/2/index.html","hash":"022cd5cd7c053235d4ef3a50209162f6e58b980d","modified":1593335020264},{"_id":"public/archives/2020/index.html","hash":"6d94a49fee159241db614d595f4179a62eb4aab3","modified":1593335020264},{"_id":"public/archives/2020/05/index.html","hash":"cc5eb47050e840357ec7624e7f983fcbb7a0bda4","modified":1593335020264},{"_id":"public/archives/2020/05/page/2/index.html","hash":"57bba4b379d803d76b48868c234d110b62a2bb22","modified":1593335020264},{"_id":"public/archives/2020/06/index.html","hash":"452c4102e7a1ab84d19ba4d43d384473f83e63fc","modified":1593335020264},{"_id":"public/categories/react/index.html","hash":"3c2adc8f718a12a58d2bfe7807c243903e86ea4a","modified":1593335020264},{"_id":"public/categories/react/page/2/index.html","hash":"6ce8732f7df0bd0130d75745f4de45831233c3ea","modified":1593335020264},{"_id":"public/2020/06/01/react-16/index.html","hash":"191f2344d9e611d232180c13501d9a1cea680d15","modified":1593335020264},{"_id":"public/2020/06/01/react-15/index.html","hash":"a947e8c08bc55ca4104d1364ee396d728f0e5325","modified":1593335020264},{"_id":"public/2020/05/30/react-14/index.html","hash":"891ab6fc4aa61d1b43528222510cd38e601124f0","modified":1593335020264},{"_id":"public/2020/05/30/react-11/index.html","hash":"9d8cd21229746c6d34b0701eb8dfee1b8ac0e3ae","modified":1593335020264},{"_id":"public/2020/05/27/react-09/index.html","hash":"a8daf49f88a1394983f1adea66083dd4681e0632","modified":1593335020264},{"_id":"public/2020/05/27/react-08/index.html","hash":"bdae2278f88681f28ca10e5e5ff09676055c9f7a","modified":1593335020264},{"_id":"public/2020/05/27/react-07/index.html","hash":"1fdfaaacc6a05fb530b2577c9bf4d7affa7c75cb","modified":1593335020264},{"_id":"public/2020/05/27/react-06/index.html","hash":"44b5b50fe8cdd7880ea3e0ef16e596395149f462","modified":1593335020264},{"_id":"public/2020/05/27/react-05/index.html","hash":"d4ed6db46f659cc3a0859336a0bdd690ae842b85","modified":1593335020264},{"_id":"public/index.html","hash":"d6bc5f96b6f8ca6232dc4b5754ef4987819b417e","modified":1593335020264},{"_id":"public/page/2/index.html","hash":"f120c30582b1cfd4b0becb09a48392e9b5034784","modified":1593335020264},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1593335020264},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1593335020264},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1593335020264},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1593335020264},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1593335020264},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1593335020264},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1593335020264},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1593335020264},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1593335020264},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1593335020264},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1593335020264},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1593335020264},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1593335020264},{"_id":"public/images/header.jpg","hash":"1c2c8ebbc155937aa47d1763b3773bb383634ace","modified":1593335020264},{"_id":"public/lib/canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1593335020264},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1593335020264},{"_id":"public/live2dw/assets/hijiki.model.json","hash":"feff43bf7498d213982c3736c2c029664e4bcbd2","modified":1593335020264},{"_id":"public/live2dw/assets/hijiki.pose.json","hash":"81438bf69b32c7c11e311b4fe043730cdc7b7ec2","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/00_idle.mtn","hash":"b224c60e463b9f71ddbfc0c720e430496c175f4f","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/02.mtn","hash":"7eafc52edc73b7cb80ae70d34b43c6ac778fa47b","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/01.mtn","hash":"fb550833ae22c9954c3e01df37ed29b2d61700f2","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/03.mtn","hash":"f900737c7a98441cbb2e05255427e6260e19ae68","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/04.mtn","hash":"c7a25d3c5d783639bae18db2f3cd284b819c3c85","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/05.mtn","hash":"dd20ad24b5d1830a5d44b9bccb28f922eea5e0e5","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/06.mtn","hash":"ad404bd852d276cdd3d054c953e23f90e4e45ae1","modified":1593335020264},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/07.mtn","hash":"b7f2e3a9fa4f3ffbb6e64a08f8d9f45ca1868ffb","modified":1593335020264},{"_id":"public/live2dw/assets/mtn/08.mtn","hash":"4411c7651ff65195b113d95e7d5ebef8a59a37d9","modified":1593335020264},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1593335020264},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1593335020264},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1593335020264},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1593335020264},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1593335020264},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1593335020264},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1593335020264},{"_id":"public/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1593335020264},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1593335020264},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1593335020264},{"_id":"public/js/src/clicklove.js","hash":"effa770d8085f7e7fb903de217ce521dff163780","modified":1593335020264},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1593335020264},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1593335020264},{"_id":"public/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"956eada198babd00f028e8908767cb158926c3f3","modified":1593335020264},{"_id":"public/lib/canvas-nest/README.html","hash":"6a5228d4ceda40e33a8602d01fdf531403f0bdf4","modified":1593335020264},{"_id":"public/css/main.css","hash":"7a97e6c209f5d0fd18a83848c5ec3086a9937dec","modified":1593335020264},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1593335020264},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1593335020264},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1593335020264},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1593335020264},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1593335020264},{"_id":"public/live2dw/assets/moc/hijiki.2048/texture_00.png","hash":"66464e0d96439695b5542c5e2f5be60739c29999","modified":1593335020264},{"_id":"public/live2dw/assets/moc/hijiki.moc","hash":"44289e62545a7046e0f5231103a851750b78524e","modified":1593335020264},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1593335020264}],"Category":[{"name":"react","_id":"ckbyuj6aj0004xy0i7ay5cp99"}],"Data":[],"Page":[{"title":"分类","date":"2020-05-21T10:19:57.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-05-21 18:19:57\n---","updated":"2020-05-25T02:53:33.446Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckbyuj6ag0001xy0i0mcn3c0q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"React","date":"2020-05-21T10:19:57.000Z","_content":"\n1. [React前言](/2020/05/26/react-01/)\n2. [React简介和Vue对比](/2020/05/26/react-02/)\n3. [React开发环境搭建](/2020/05/26/react-03/)\n4. [脚手架生成的项目目录介绍](/2020/05/26/react-04/)\n5. [HelloWord 和组件的讲解](/2020/05/27/react-05/)\n6. [React中jsx语法简介](/2020/05/27/react-06/)\n7. [React响应式设计原理和数据绑定](/2020/05/27/react-07/)\n8. [React实例](/2020/05/27/react-08/)\n9. [React进阶——JSX踩坑的几个地方](/2020/05/27/react-09/)\n10. [React进阶——安装Simple React Snippets](/2020/05/30/react-10/)\n11. [React进阶——父子组件的传值](/2020/05/30/react-11/)\n12. [React进阶——单项数据流和其他](/2020/05/30/react-12/)\n13. [React高级——调试工具的安装及使用](/2020/05/30/react-13/)\n14. [React高级——PropTypes校验传递值](/2020/05/30/react-14/)\n15. [React高级——ref的使用方法](/2020/06/01/react-15/)\n16. [React高级——生命周期](/2020/06/01/react-16/)\n17. [React高级——生命周期改善程序性能](/2020/06/28/react-17/)\n18. [React高级——axios数据请求](/2020/06/28/react-18/)\n\n    \n\n\n","source":"react/index.md","raw":"---\ntitle: React\ndate: 2020-05-21 18:19:57\n---\n\n1. [React前言](/2020/05/26/react-01/)\n2. [React简介和Vue对比](/2020/05/26/react-02/)\n3. [React开发环境搭建](/2020/05/26/react-03/)\n4. [脚手架生成的项目目录介绍](/2020/05/26/react-04/)\n5. [HelloWord 和组件的讲解](/2020/05/27/react-05/)\n6. [React中jsx语法简介](/2020/05/27/react-06/)\n7. [React响应式设计原理和数据绑定](/2020/05/27/react-07/)\n8. [React实例](/2020/05/27/react-08/)\n9. [React进阶——JSX踩坑的几个地方](/2020/05/27/react-09/)\n10. [React进阶——安装Simple React Snippets](/2020/05/30/react-10/)\n11. [React进阶——父子组件的传值](/2020/05/30/react-11/)\n12. [React进阶——单项数据流和其他](/2020/05/30/react-12/)\n13. [React高级——调试工具的安装及使用](/2020/05/30/react-13/)\n14. [React高级——PropTypes校验传递值](/2020/05/30/react-14/)\n15. [React高级——ref的使用方法](/2020/06/01/react-15/)\n16. [React高级——生命周期](/2020/06/01/react-16/)\n17. [React高级——生命周期改善程序性能](/2020/06/28/react-17/)\n18. [React高级——axios数据请求](/2020/06/28/react-18/)\n\n    \n\n\n","updated":"2020-06-28T08:50:32.338Z","path":"react/index.html","comments":1,"layout":"page","_id":"ckbyuj6ai0003xy0i7il6epxu","content":"<ol>\n<li><a href=\"/2020/05/26/react-01/\">React前言</a></li>\n<li><a href=\"/2020/05/26/react-02/\">React简介和Vue对比</a></li>\n<li><a href=\"/2020/05/26/react-03/\">React开发环境搭建</a></li>\n<li><a href=\"/2020/05/26/react-04/\">脚手架生成的项目目录介绍</a></li>\n<li><a href=\"/2020/05/27/react-05/\">HelloWord 和组件的讲解</a></li>\n<li><a href=\"/2020/05/27/react-06/\">React中jsx语法简介</a></li>\n<li><a href=\"/2020/05/27/react-07/\">React响应式设计原理和数据绑定</a></li>\n<li><a href=\"/2020/05/27/react-08/\">React实例</a></li>\n<li><a href=\"/2020/05/27/react-09/\">React进阶——JSX踩坑的几个地方</a></li>\n<li><a href=\"/2020/05/30/react-10/\">React进阶——安装Simple React Snippets</a></li>\n<li><a href=\"/2020/05/30/react-11/\">React进阶——父子组件的传值</a></li>\n<li><a href=\"/2020/05/30/react-12/\">React进阶——单项数据流和其他</a></li>\n<li><a href=\"/2020/05/30/react-13/\">React高级——调试工具的安装及使用</a></li>\n<li><a href=\"/2020/05/30/react-14/\">React高级——PropTypes校验传递值</a></li>\n<li><a href=\"/2020/06/01/react-15/\">React高级——ref的使用方法</a></li>\n<li><a href=\"/2020/06/01/react-16/\">React高级——生命周期</a></li>\n<li><a href=\"/2020/06/28/react-17/\">React高级——生命周期改善程序性能</a></li>\n<li><a href=\"/2020/06/28/react-18/\">React高级——axios数据请求</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><a href=\"/2020/05/26/react-01/\">React前言</a></li>\n<li><a href=\"/2020/05/26/react-02/\">React简介和Vue对比</a></li>\n<li><a href=\"/2020/05/26/react-03/\">React开发环境搭建</a></li>\n<li><a href=\"/2020/05/26/react-04/\">脚手架生成的项目目录介绍</a></li>\n<li><a href=\"/2020/05/27/react-05/\">HelloWord 和组件的讲解</a></li>\n<li><a href=\"/2020/05/27/react-06/\">React中jsx语法简介</a></li>\n<li><a href=\"/2020/05/27/react-07/\">React响应式设计原理和数据绑定</a></li>\n<li><a href=\"/2020/05/27/react-08/\">React实例</a></li>\n<li><a href=\"/2020/05/27/react-09/\">React进阶——JSX踩坑的几个地方</a></li>\n<li><a href=\"/2020/05/30/react-10/\">React进阶——安装Simple React Snippets</a></li>\n<li><a href=\"/2020/05/30/react-11/\">React进阶——父子组件的传值</a></li>\n<li><a href=\"/2020/05/30/react-12/\">React进阶——单项数据流和其他</a></li>\n<li><a href=\"/2020/05/30/react-13/\">React高级——调试工具的安装及使用</a></li>\n<li><a href=\"/2020/05/30/react-14/\">React高级——PropTypes校验传递值</a></li>\n<li><a href=\"/2020/06/01/react-15/\">React高级——ref的使用方法</a></li>\n<li><a href=\"/2020/06/01/react-16/\">React高级——生命周期</a></li>\n<li><a href=\"/2020/06/28/react-17/\">React高级——生命周期改善程序性能</a></li>\n<li><a href=\"/2020/06/28/react-18/\">React高级——axios数据请求</a></li>\n</ol>\n"}],"Post":[{"title":"脚手架生成的项目目录介绍","date":"2020-05-26T06:00:32.000Z","_content":"\n### 项目根目录中的文件\n\n先从进入项目根目录说起，也就是第一眼看到的文件(版本不同，可能稍有不同)\n\n- **README.md** :这个文件主要作用就是对项目的说明，已经默认写好了一些东西，你可以简单看看。如果是工作中，你可以把文件中的内容删除，自己来写这个文件，编写这个文件可以使用`Markdown`的语法来编写。\n- **package.json**: 这个文件是`webpack`配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置，当然脚手架已经为我们配置了一些了，目前位置，我们不需要改动。如果你对webpack了解，对这个一定也很熟悉。\n- **package-lock.json**：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再`npm install` 时大家的依赖能保证一致。\n- **gitignore** : 这个是git的选择性上传的配置文件，比如一会要介绍的`node_modules`文件夹，就需要配置不上传。\n- **node_modules** :这个文件夹就是我们项目的依赖包，到目前位置，脚手架已经都给我们下载好了，你不需要单独安装什么。\n- **public** ：公共文件，里边有公用模板和图标等一些东西。\n- **src** ： 主要代码编写文件，这个文件夹里的文件对我们来说最重要，都需要我们掌握。\n\n### public文件夹介绍\n\n这个文件都是一些项目使用的公共文件，也就是说都是共用的，我们就具体看一下有那些文件吧。\n\n- **favicon.ico** : 这个是网站或者说项目的图标，一般在浏览器标签页的左上角显示。\n- **index.html** : 首页的模板文件，我们可以试着改动一下，就能看到结果。\n- **mainifest.json**：移动端配置文件，这个会在以后的课程中详细讲解。\n\n### src文件夹介绍\n\n这个目录里边放的是我们开放的源代码，我们平时操作做最多的目录。\n\n- **index.js** : 这个就是项目的入口文件，视频中我们会简单的看一下这个文件。\n- **index.css** ：这个是`index.js`里的CSS文件。\n- **app.js** : 这个文件相当于一个方法模块，也是一个简单的模块化编程。\n- **serviceWorker.js**: 这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。","source":"_posts/react-04.md","raw":"---\ntitle: 脚手架生成的项目目录介绍\ndate: 2020-05-26 14:00:32\ntags:\ncategories: react\n---\n\n### 项目根目录中的文件\n\n先从进入项目根目录说起，也就是第一眼看到的文件(版本不同，可能稍有不同)\n\n- **README.md** :这个文件主要作用就是对项目的说明，已经默认写好了一些东西，你可以简单看看。如果是工作中，你可以把文件中的内容删除，自己来写这个文件，编写这个文件可以使用`Markdown`的语法来编写。\n- **package.json**: 这个文件是`webpack`配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置，当然脚手架已经为我们配置了一些了，目前位置，我们不需要改动。如果你对webpack了解，对这个一定也很熟悉。\n- **package-lock.json**：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再`npm install` 时大家的依赖能保证一致。\n- **gitignore** : 这个是git的选择性上传的配置文件，比如一会要介绍的`node_modules`文件夹，就需要配置不上传。\n- **node_modules** :这个文件夹就是我们项目的依赖包，到目前位置，脚手架已经都给我们下载好了，你不需要单独安装什么。\n- **public** ：公共文件，里边有公用模板和图标等一些东西。\n- **src** ： 主要代码编写文件，这个文件夹里的文件对我们来说最重要，都需要我们掌握。\n\n### public文件夹介绍\n\n这个文件都是一些项目使用的公共文件，也就是说都是共用的，我们就具体看一下有那些文件吧。\n\n- **favicon.ico** : 这个是网站或者说项目的图标，一般在浏览器标签页的左上角显示。\n- **index.html** : 首页的模板文件，我们可以试着改动一下，就能看到结果。\n- **mainifest.json**：移动端配置文件，这个会在以后的课程中详细讲解。\n\n### src文件夹介绍\n\n这个目录里边放的是我们开放的源代码，我们平时操作做最多的目录。\n\n- **index.js** : 这个就是项目的入口文件，视频中我们会简单的看一下这个文件。\n- **index.css** ：这个是`index.js`里的CSS文件。\n- **app.js** : 这个文件相当于一个方法模块，也是一个简单的模块化编程。\n- **serviceWorker.js**: 这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。","slug":"react-04","published":1,"updated":"2020-05-27T06:50:44.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6ad0000xy0ic889g4l6","content":"<h3 id=\"项目根目录中的文件\"><a href=\"#项目根目录中的文件\" class=\"headerlink\" title=\"项目根目录中的文件\"></a>项目根目录中的文件</h3><p>先从进入项目根目录说起，也就是第一眼看到的文件(版本不同，可能稍有不同)</p>\n<ul>\n<li><strong>README.md</strong> :这个文件主要作用就是对项目的说明，已经默认写好了一些东西，你可以简单看看。如果是工作中，你可以把文件中的内容删除，自己来写这个文件，编写这个文件可以使用<code>Markdown</code>的语法来编写。</li>\n<li><strong>package.json</strong>: 这个文件是<code>webpack</code>配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置，当然脚手架已经为我们配置了一些了，目前位置，我们不需要改动。如果你对webpack了解，对这个一定也很熟悉。</li>\n<li><strong>package-lock.json</strong>：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再<code>npm install</code> 时大家的依赖能保证一致。</li>\n<li><strong>gitignore</strong> : 这个是git的选择性上传的配置文件，比如一会要介绍的<code>node_modules</code>文件夹，就需要配置不上传。</li>\n<li><strong>node_modules</strong> :这个文件夹就是我们项目的依赖包，到目前位置，脚手架已经都给我们下载好了，你不需要单独安装什么。</li>\n<li><strong>public</strong> ：公共文件，里边有公用模板和图标等一些东西。</li>\n<li><strong>src</strong> ： 主要代码编写文件，这个文件夹里的文件对我们来说最重要，都需要我们掌握。</li>\n</ul>\n<h3 id=\"public文件夹介绍\"><a href=\"#public文件夹介绍\" class=\"headerlink\" title=\"public文件夹介绍\"></a>public文件夹介绍</h3><p>这个文件都是一些项目使用的公共文件，也就是说都是共用的，我们就具体看一下有那些文件吧。</p>\n<ul>\n<li><strong>favicon.ico</strong> : 这个是网站或者说项目的图标，一般在浏览器标签页的左上角显示。</li>\n<li><strong>index.html</strong> : 首页的模板文件，我们可以试着改动一下，就能看到结果。</li>\n<li><strong>mainifest.json</strong>：移动端配置文件，这个会在以后的课程中详细讲解。</li>\n</ul>\n<h3 id=\"src文件夹介绍\"><a href=\"#src文件夹介绍\" class=\"headerlink\" title=\"src文件夹介绍\"></a>src文件夹介绍</h3><p>这个目录里边放的是我们开放的源代码，我们平时操作做最多的目录。</p>\n<ul>\n<li><strong>index.js</strong> : 这个就是项目的入口文件，视频中我们会简单的看一下这个文件。</li>\n<li><strong>index.css</strong> ：这个是<code>index.js</code>里的CSS文件。</li>\n<li><strong>app.js</strong> : 这个文件相当于一个方法模块，也是一个简单的模块化编程。</li>\n<li><strong>serviceWorker.js</strong>: 这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"项目根目录中的文件\"><a href=\"#项目根目录中的文件\" class=\"headerlink\" title=\"项目根目录中的文件\"></a>项目根目录中的文件</h3><p>先从进入项目根目录说起，也就是第一眼看到的文件(版本不同，可能稍有不同)</p>\n<ul>\n<li><strong>README.md</strong> :这个文件主要作用就是对项目的说明，已经默认写好了一些东西，你可以简单看看。如果是工作中，你可以把文件中的内容删除，自己来写这个文件，编写这个文件可以使用<code>Markdown</code>的语法来编写。</li>\n<li><strong>package.json</strong>: 这个文件是<code>webpack</code>配置和项目包管理文件，项目中依赖的第三方包（包的版本）和一些常用命令配置都在这个里边进行配置，当然脚手架已经为我们配置了一些了，目前位置，我们不需要改动。如果你对webpack了解，对这个一定也很熟悉。</li>\n<li><strong>package-lock.json</strong>：这个文件用一句话来解释，就是锁定安装时的版本号，并且需要上传到git，以保证其他人再<code>npm install</code> 时大家的依赖能保证一致。</li>\n<li><strong>gitignore</strong> : 这个是git的选择性上传的配置文件，比如一会要介绍的<code>node_modules</code>文件夹，就需要配置不上传。</li>\n<li><strong>node_modules</strong> :这个文件夹就是我们项目的依赖包，到目前位置，脚手架已经都给我们下载好了，你不需要单独安装什么。</li>\n<li><strong>public</strong> ：公共文件，里边有公用模板和图标等一些东西。</li>\n<li><strong>src</strong> ： 主要代码编写文件，这个文件夹里的文件对我们来说最重要，都需要我们掌握。</li>\n</ul>\n<h3 id=\"public文件夹介绍\"><a href=\"#public文件夹介绍\" class=\"headerlink\" title=\"public文件夹介绍\"></a>public文件夹介绍</h3><p>这个文件都是一些项目使用的公共文件，也就是说都是共用的，我们就具体看一下有那些文件吧。</p>\n<ul>\n<li><strong>favicon.ico</strong> : 这个是网站或者说项目的图标，一般在浏览器标签页的左上角显示。</li>\n<li><strong>index.html</strong> : 首页的模板文件，我们可以试着改动一下，就能看到结果。</li>\n<li><strong>mainifest.json</strong>：移动端配置文件，这个会在以后的课程中详细讲解。</li>\n</ul>\n<h3 id=\"src文件夹介绍\"><a href=\"#src文件夹介绍\" class=\"headerlink\" title=\"src文件夹介绍\"></a>src文件夹介绍</h3><p>这个目录里边放的是我们开放的源代码，我们平时操作做最多的目录。</p>\n<ul>\n<li><strong>index.js</strong> : 这个就是项目的入口文件，视频中我们会简单的看一下这个文件。</li>\n<li><strong>index.css</strong> ：这个是<code>index.js</code>里的CSS文件。</li>\n<li><strong>app.js</strong> : 这个文件相当于一个方法模块，也是一个简单的模块化编程。</li>\n<li><strong>serviceWorker.js</strong>: 这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。</li>\n</ul>\n"},{"title":"React 前言","date":"2020-05-26T05:59:39.000Z","_content":"\n### React简介\n\nReact.js是全国做火的前端框架（Facebook推出的前端框架），国内的一二线互联网公司大部分都在使用React进行开发，比如阿里、美团、百度、去哪儿、网易 、知乎这样的一线互联网公司都把React作为前端主要技术栈。\n\nReact的社区很强大，随着React的普及衍生了很多有用的框架，比如ReactNative和React VR。React是从13开始推广的。\n\n### React优点总结\n\n- **生态强大**：现在没有哪个框架比React的生态体系好的，几乎所有开发需求都有成熟的解决方案。\n- **上手简单**: 可以在几个小时内就可以上手React技术，但是他的知识很广，可能需要更多的时间来完全驾驭它。\n- **社区强大**\n\n### 需要的前置知识\n\n- **JavaScript基础**：如果能会ES6就更好了\n- **npm基础**：你需要会使用npm的包管理","source":"_posts/react-01.md","raw":"---\ntitle: React 前言\ndate: 2020-05-26 13:59:39\ntags: \ncategories: react\n---\n\n### React简介\n\nReact.js是全国做火的前端框架（Facebook推出的前端框架），国内的一二线互联网公司大部分都在使用React进行开发，比如阿里、美团、百度、去哪儿、网易 、知乎这样的一线互联网公司都把React作为前端主要技术栈。\n\nReact的社区很强大，随着React的普及衍生了很多有用的框架，比如ReactNative和React VR。React是从13开始推广的。\n\n### React优点总结\n\n- **生态强大**：现在没有哪个框架比React的生态体系好的，几乎所有开发需求都有成熟的解决方案。\n- **上手简单**: 可以在几个小时内就可以上手React技术，但是他的知识很广，可能需要更多的时间来完全驾驭它。\n- **社区强大**\n\n### 需要的前置知识\n\n- **JavaScript基础**：如果能会ES6就更好了\n- **npm基础**：你需要会使用npm的包管理","slug":"react-01","published":1,"updated":"2020-05-27T06:50:27.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6ah0002xy0i4k0364bf","content":"<h3 id=\"React简介\"><a href=\"#React简介\" class=\"headerlink\" title=\"React简介\"></a>React简介</h3><p>React.js是全国做火的前端框架（Facebook推出的前端框架），国内的一二线互联网公司大部分都在使用React进行开发，比如阿里、美团、百度、去哪儿、网易 、知乎这样的一线互联网公司都把React作为前端主要技术栈。</p>\n<p>React的社区很强大，随着React的普及衍生了很多有用的框架，比如ReactNative和React VR。React是从13开始推广的。</p>\n<h3 id=\"React优点总结\"><a href=\"#React优点总结\" class=\"headerlink\" title=\"React优点总结\"></a>React优点总结</h3><ul>\n<li><strong>生态强大</strong>：现在没有哪个框架比React的生态体系好的，几乎所有开发需求都有成熟的解决方案。</li>\n<li><strong>上手简单</strong>: 可以在几个小时内就可以上手React技术，但是他的知识很广，可能需要更多的时间来完全驾驭它。</li>\n<li><strong>社区强大</strong></li>\n</ul>\n<h3 id=\"需要的前置知识\"><a href=\"#需要的前置知识\" class=\"headerlink\" title=\"需要的前置知识\"></a>需要的前置知识</h3><ul>\n<li><strong>JavaScript基础</strong>：如果能会ES6就更好了</li>\n<li><strong>npm基础</strong>：你需要会使用npm的包管理</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"React简介\"><a href=\"#React简介\" class=\"headerlink\" title=\"React简介\"></a>React简介</h3><p>React.js是全国做火的前端框架（Facebook推出的前端框架），国内的一二线互联网公司大部分都在使用React进行开发，比如阿里、美团、百度、去哪儿、网易 、知乎这样的一线互联网公司都把React作为前端主要技术栈。</p>\n<p>React的社区很强大，随着React的普及衍生了很多有用的框架，比如ReactNative和React VR。React是从13开始推广的。</p>\n<h3 id=\"React优点总结\"><a href=\"#React优点总结\" class=\"headerlink\" title=\"React优点总结\"></a>React优点总结</h3><ul>\n<li><strong>生态强大</strong>：现在没有哪个框架比React的生态体系好的，几乎所有开发需求都有成熟的解决方案。</li>\n<li><strong>上手简单</strong>: 可以在几个小时内就可以上手React技术，但是他的知识很广，可能需要更多的时间来完全驾驭它。</li>\n<li><strong>社区强大</strong></li>\n</ul>\n<h3 id=\"需要的前置知识\"><a href=\"#需要的前置知识\" class=\"headerlink\" title=\"需要的前置知识\"></a>需要的前置知识</h3><ul>\n<li><strong>JavaScript基础</strong>：如果能会ES6就更好了</li>\n<li><strong>npm基础</strong>：你需要会使用npm的包管理</li>\n</ul>\n"},{"title":"React开发环境搭建","date":"2020-05-26T06:00:25.000Z","_content":"\n### 安装Node.js\n\n使用`React.js`是可以用最原始的``标签进行引入的工作中也不会有这种形式进行引入。所以就采用脚手架形式的安装。这就需要先安装`Node.js`，用里边的`npm`来进行安装。\n\nNode中文网址：[http://nodejs.cn/](http://nodejs.cn/)\n\nNode.js` 安装好以后，如果是Windows系统，可以使用 `Win+R`打开运行，然后输入`cmd`，打开终端（或者叫命令行工具）\n\n```\nnode -v\n```\n\n如果正确出现版本号，说明Node安装成功了\n\n然后再输入代码:\n\n```\nnpm -v\n```\n\n如果正确出现版本号，说明npm也是没问题的，这时候`Node.js`安装就算完成了。\n\n### 脚手架的安装\n\nNode安装好之后，你就可以使用npm命令来安装脚手架工具了，方法很简单，只要打开终端，然后输入下面的命令就可以了。\n\n```\nnpm install -g create-react-app\n```\n\n创建第一个React项目\n\n","source":"_posts/react-03.md","raw":"---\ntitle: React开发环境搭建\ndate: 2020-05-26 14:00:25\ntags:\ncategories: react\n---\n\n### 安装Node.js\n\n使用`React.js`是可以用最原始的``标签进行引入的工作中也不会有这种形式进行引入。所以就采用脚手架形式的安装。这就需要先安装`Node.js`，用里边的`npm`来进行安装。\n\nNode中文网址：[http://nodejs.cn/](http://nodejs.cn/)\n\nNode.js` 安装好以后，如果是Windows系统，可以使用 `Win+R`打开运行，然后输入`cmd`，打开终端（或者叫命令行工具）\n\n```\nnode -v\n```\n\n如果正确出现版本号，说明Node安装成功了\n\n然后再输入代码:\n\n```\nnpm -v\n```\n\n如果正确出现版本号，说明npm也是没问题的，这时候`Node.js`安装就算完成了。\n\n### 脚手架的安装\n\nNode安装好之后，你就可以使用npm命令来安装脚手架工具了，方法很简单，只要打开终端，然后输入下面的命令就可以了。\n\n```\nnpm install -g create-react-app\n```\n\n创建第一个React项目\n\n","slug":"react-03","published":1,"updated":"2020-05-27T06:50:41.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6ak0005xy0i56tx88es","content":"<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>使用<code>React.js</code>是可以用最原始的``标签进行引入的工作中也不会有这种形式进行引入。所以就采用脚手架形式的安装。这就需要先安装<code>Node.js</code>，用里边的<code>npm</code>来进行安装。</p>\n<p>Node中文网址：<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/</a></p>\n<p>Node.js<code>安装好以后，如果是Windows系统，可以使用</code>Win+R<code>打开运行，然后输入</code>cmd`，打开终端（或者叫命令行工具）</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">node</span> <span class=\"title\">-v</span></span><br></pre></td></tr></table></figure>\n\n<p>如果正确出现版本号，说明Node安装成功了</p>\n<p>然后再输入代码:</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> -v</span><br></pre></td></tr></table></figure>\n\n<p>如果正确出现版本号，说明npm也是没问题的，这时候<code>Node.js</code>安装就算完成了。</p>\n<h3 id=\"脚手架的安装\"><a href=\"#脚手架的安装\" class=\"headerlink\" title=\"脚手架的安装\"></a>脚手架的安装</h3><p>Node安装好之后，你就可以使用npm命令来安装脚手架工具了，方法很简单，只要打开终端，然后输入下面的命令就可以了。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> -g <span class=\"keyword\">create</span>-react-app</span><br></pre></td></tr></table></figure>\n\n<p>创建第一个React项目</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>使用<code>React.js</code>是可以用最原始的``标签进行引入的工作中也不会有这种形式进行引入。所以就采用脚手架形式的安装。这就需要先安装<code>Node.js</code>，用里边的<code>npm</code>来进行安装。</p>\n<p>Node中文网址：<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/</a></p>\n<p>Node.js<code>安装好以后，如果是Windows系统，可以使用</code>Win+R<code>打开运行，然后输入</code>cmd`，打开终端（或者叫命令行工具）</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">node</span> <span class=\"title\">-v</span></span><br></pre></td></tr></table></figure>\n\n<p>如果正确出现版本号，说明Node安装成功了</p>\n<p>然后再输入代码:</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">npm</span> -v</span><br></pre></td></tr></table></figure>\n\n<p>如果正确出现版本号，说明npm也是没问题的，这时候<code>Node.js</code>安装就算完成了。</p>\n<h3 id=\"脚手架的安装\"><a href=\"#脚手架的安装\" class=\"headerlink\" title=\"脚手架的安装\"></a>脚手架的安装</h3><p>Node安装好之后，你就可以使用npm命令来安装脚手架工具了，方法很简单，只要打开终端，然后输入下面的命令就可以了。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> -g <span class=\"keyword\">create</span>-react-app</span><br></pre></td></tr></table></figure>\n\n<p>创建第一个React项目</p>\n"},{"title":"React简介 和 Vue对比","date":"2020-05-26T06:00:18.000Z","_content":"\n### React简介\n\nReact用于构建用户界面的JavaScript库\n\n### React三大体系\n\n![React三大体系](https://gitee.com/sunshine58/image-oss/raw/master/uPic/2020-05/React三大体系.png)\n\n首先先学会`React.js`的基本知识，然后再学习`ReactNative`,这样学习难度会大大降低。\n\n### 正式简介\n\n`ReactJS`是由Facebook在2013年5月推出的一款JS前端**开源**框架,推出式主打特点式**函数式编程**风格。值得一说的是，到目前为止`ReactJS`是世界上使用人数最多的前端框架,它拥有全球最健全的文档和社区体系。\n\nReactJS的官方网站[https://reactjs.org/](https://reactjs.org/)\n\n### React与Vue对比\n\n这是前端最火的两个框架，虽然说React是世界使用人数最多的框架，但是就在国内而言Vue的使用者很有可能超过React。两个框架都是非常优秀的，所以他们在技术和先进性上不相上下。\n\n那个人而言在接到一个项目时，我是如何选择的那？`React.js`相对于`Vue.js`它的灵活性和协作性更好一点，所以我在处理复杂项目或公司核心项目时，React都是我的第一选择。而`Vue.js`有着丰富的API，实现起来更简单快速，所以当团队不大，沟通紧密时，我会选择Vue，因为它更快速更易用。（需要说明的是，其实Vue也完全胜任于大型项目，这要根据自己对框架的掌握程度来决定，以上只是站在我的知识程度基础上的个人总结）\n\n","source":"_posts/react-02.md","raw":"---\ntitle: React简介 和 Vue对比\ndate: 2020-05-26 14:00:18\ntags:\ncategories: react\n---\n\n### React简介\n\nReact用于构建用户界面的JavaScript库\n\n### React三大体系\n\n![React三大体系](https://gitee.com/sunshine58/image-oss/raw/master/uPic/2020-05/React三大体系.png)\n\n首先先学会`React.js`的基本知识，然后再学习`ReactNative`,这样学习难度会大大降低。\n\n### 正式简介\n\n`ReactJS`是由Facebook在2013年5月推出的一款JS前端**开源**框架,推出式主打特点式**函数式编程**风格。值得一说的是，到目前为止`ReactJS`是世界上使用人数最多的前端框架,它拥有全球最健全的文档和社区体系。\n\nReactJS的官方网站[https://reactjs.org/](https://reactjs.org/)\n\n### React与Vue对比\n\n这是前端最火的两个框架，虽然说React是世界使用人数最多的框架，但是就在国内而言Vue的使用者很有可能超过React。两个框架都是非常优秀的，所以他们在技术和先进性上不相上下。\n\n那个人而言在接到一个项目时，我是如何选择的那？`React.js`相对于`Vue.js`它的灵活性和协作性更好一点，所以我在处理复杂项目或公司核心项目时，React都是我的第一选择。而`Vue.js`有着丰富的API，实现起来更简单快速，所以当团队不大，沟通紧密时，我会选择Vue，因为它更快速更易用。（需要说明的是，其实Vue也完全胜任于大型项目，这要根据自己对框架的掌握程度来决定，以上只是站在我的知识程度基础上的个人总结）\n\n","slug":"react-02","published":1,"updated":"2020-05-27T06:50:34.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6al0006xy0i30a4cqpb","content":"<h3 id=\"React简介\"><a href=\"#React简介\" class=\"headerlink\" title=\"React简介\"></a>React简介</h3><p>React用于构建用户界面的JavaScript库</p>\n<h3 id=\"React三大体系\"><a href=\"#React三大体系\" class=\"headerlink\" title=\"React三大体系\"></a>React三大体系</h3><p><img src=\"https://gitee.com/sunshine58/image-oss/raw/master/uPic/2020-05/React%E4%B8%89%E5%A4%A7%E4%BD%93%E7%B3%BB.png\" alt=\"React三大体系\"></p>\n<p>首先先学会<code>React.js</code>的基本知识，然后再学习<code>ReactNative</code>,这样学习难度会大大降低。</p>\n<h3 id=\"正式简介\"><a href=\"#正式简介\" class=\"headerlink\" title=\"正式简介\"></a>正式简介</h3><p><code>ReactJS</code>是由Facebook在2013年5月推出的一款JS前端<strong>开源</strong>框架,推出式主打特点式<strong>函数式编程</strong>风格。值得一说的是，到目前为止<code>ReactJS</code>是世界上使用人数最多的前端框架,它拥有全球最健全的文档和社区体系。</p>\n<p>ReactJS的官方网站<a href=\"https://reactjs.org/\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/</a></p>\n<h3 id=\"React与Vue对比\"><a href=\"#React与Vue对比\" class=\"headerlink\" title=\"React与Vue对比\"></a>React与Vue对比</h3><p>这是前端最火的两个框架，虽然说React是世界使用人数最多的框架，但是就在国内而言Vue的使用者很有可能超过React。两个框架都是非常优秀的，所以他们在技术和先进性上不相上下。</p>\n<p>那个人而言在接到一个项目时，我是如何选择的那？<code>React.js</code>相对于<code>Vue.js</code>它的灵活性和协作性更好一点，所以我在处理复杂项目或公司核心项目时，React都是我的第一选择。而<code>Vue.js</code>有着丰富的API，实现起来更简单快速，所以当团队不大，沟通紧密时，我会选择Vue，因为它更快速更易用。（需要说明的是，其实Vue也完全胜任于大型项目，这要根据自己对框架的掌握程度来决定，以上只是站在我的知识程度基础上的个人总结）</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"React简介\"><a href=\"#React简介\" class=\"headerlink\" title=\"React简介\"></a>React简介</h3><p>React用于构建用户界面的JavaScript库</p>\n<h3 id=\"React三大体系\"><a href=\"#React三大体系\" class=\"headerlink\" title=\"React三大体系\"></a>React三大体系</h3><p><img src=\"https://gitee.com/sunshine58/image-oss/raw/master/uPic/2020-05/React%E4%B8%89%E5%A4%A7%E4%BD%93%E7%B3%BB.png\" alt=\"React三大体系\"></p>\n<p>首先先学会<code>React.js</code>的基本知识，然后再学习<code>ReactNative</code>,这样学习难度会大大降低。</p>\n<h3 id=\"正式简介\"><a href=\"#正式简介\" class=\"headerlink\" title=\"正式简介\"></a>正式简介</h3><p><code>ReactJS</code>是由Facebook在2013年5月推出的一款JS前端<strong>开源</strong>框架,推出式主打特点式<strong>函数式编程</strong>风格。值得一说的是，到目前为止<code>ReactJS</code>是世界上使用人数最多的前端框架,它拥有全球最健全的文档和社区体系。</p>\n<p>ReactJS的官方网站<a href=\"https://reactjs.org/\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/</a></p>\n<h3 id=\"React与Vue对比\"><a href=\"#React与Vue对比\" class=\"headerlink\" title=\"React与Vue对比\"></a>React与Vue对比</h3><p>这是前端最火的两个框架，虽然说React是世界使用人数最多的框架，但是就在国内而言Vue的使用者很有可能超过React。两个框架都是非常优秀的，所以他们在技术和先进性上不相上下。</p>\n<p>那个人而言在接到一个项目时，我是如何选择的那？<code>React.js</code>相对于<code>Vue.js</code>它的灵活性和协作性更好一点，所以我在处理复杂项目或公司核心项目时，React都是我的第一选择。而<code>Vue.js</code>有着丰富的API，实现起来更简单快速，所以当团队不大，沟通紧密时，我会选择Vue，因为它更快速更易用。（需要说明的是，其实Vue也完全胜任于大型项目，这要根据自己对框架的掌握程度来决定，以上只是站在我的知识程度基础上的个人总结）</p>\n"},{"title":"React中jsx语法简介","date":"2020-05-27T07:01:47.000Z","_content":"\n### JSX简介\n\n> JSX就是Javascript和XML结合的一种格式。React发明了JSX，可以方便的利用HTML语法来创建虚拟DOM，当遇到`<`，JSX就当作HTML解析，遇到`{`就当JavaScript解析.\n\n比如我们写一段JSX语法\n\n```\n<ul className=\"my-list\">\n    <li>JSPang.com</li>\n    <li>I love React</li>\n</ul>\n```\n\n比如我们以前写一段JS代码：\n\n```\nvar child1 = React.createElement('li', null, 'JSPang.com');\nvar child2 = React.createElement('li', null, 'I love React');\nvar root = React.createElement('ul', { className: 'my-list' }, child1, child2);\n```\n\n从代码量上就可以看出JSX语法大量简化了我们的工作。\n\n### 组件和普通JSX语法区别\n\n这个说起来也只有简单的一句话，就是你自定义的组件必须首写字母要进行大写，而JSX是小写字母开头的。\n\n### JSX使用三元运算符\n\n在JSX中也是可以使用js语法的，我们先简单讲解一个三元元算符的方法。\n\n```\nimport React from 'react'\nconst Component = React.Component\n\n\nclass App extends Component{\n    render(){\n        return (\n            <ul className=\"my-list\">\n                <li>{false?'zhaohui58.cn':'Sunshine'}</li>\n                <li>I love React</li>\n            </ul>\n        )\n    }\n}\n\nexport default App;\n```\n\n总结：作为一个初学者对JSX有一个简单的了解","source":"_posts/react-06.md","raw":"---\ntitle: React中jsx语法简介\ndate: 2020-05-27 15:01:47\ntags:\ncategories: react\n---\n\n### JSX简介\n\n> JSX就是Javascript和XML结合的一种格式。React发明了JSX，可以方便的利用HTML语法来创建虚拟DOM，当遇到`<`，JSX就当作HTML解析，遇到`{`就当JavaScript解析.\n\n比如我们写一段JSX语法\n\n```\n<ul className=\"my-list\">\n    <li>JSPang.com</li>\n    <li>I love React</li>\n</ul>\n```\n\n比如我们以前写一段JS代码：\n\n```\nvar child1 = React.createElement('li', null, 'JSPang.com');\nvar child2 = React.createElement('li', null, 'I love React');\nvar root = React.createElement('ul', { className: 'my-list' }, child1, child2);\n```\n\n从代码量上就可以看出JSX语法大量简化了我们的工作。\n\n### 组件和普通JSX语法区别\n\n这个说起来也只有简单的一句话，就是你自定义的组件必须首写字母要进行大写，而JSX是小写字母开头的。\n\n### JSX使用三元运算符\n\n在JSX中也是可以使用js语法的，我们先简单讲解一个三元元算符的方法。\n\n```\nimport React from 'react'\nconst Component = React.Component\n\n\nclass App extends Component{\n    render(){\n        return (\n            <ul className=\"my-list\">\n                <li>{false?'zhaohui58.cn':'Sunshine'}</li>\n                <li>I love React</li>\n            </ul>\n        )\n    }\n}\n\nexport default App;\n```\n\n总结：作为一个初学者对JSX有一个简单的了解","slug":"react-06","published":1,"updated":"2020-05-27T07:15:02.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6am0007xy0i48ah7csd","content":"<h3 id=\"JSX简介\"><a href=\"#JSX简介\" class=\"headerlink\" title=\"JSX简介\"></a>JSX简介</h3><blockquote>\n<p>JSX就是Javascript和XML结合的一种格式。React发明了JSX，可以方便的利用HTML语法来创建虚拟DOM，当遇到<code>&lt;</code>，JSX就当作HTML解析，遇到<code>{</code>就当JavaScript解析.</p>\n</blockquote>\n<p>比如我们写一段JSX语法</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">className</span>=<span class=\"string\">\"my-list\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>JSPang.com<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>I love React<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>比如我们以前写一段JS代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child1 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">React</span>.</span></span>create<span class=\"constructor\">Element('<span class=\"params\">li</span>', <span class=\"params\">null</span>, 'JSPang.<span class=\"params\">com</span>')</span>;</span><br><span class=\"line\">var child2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">React</span>.</span></span>create<span class=\"constructor\">Element('<span class=\"params\">li</span>', <span class=\"params\">null</span>, 'I <span class=\"params\">love</span> React')</span>;</span><br><span class=\"line\">var root = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">React</span>.</span></span>create<span class=\"constructor\">Element('<span class=\"params\">ul</span>', &#123; <span class=\"params\">className</span>: '<span class=\"params\">my</span>-<span class=\"params\">list</span>' &#125;, <span class=\"params\">child1</span>, <span class=\"params\">child2</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>从代码量上就可以看出JSX语法大量简化了我们的工作。</p>\n<h3 id=\"组件和普通JSX语法区别\"><a href=\"#组件和普通JSX语法区别\" class=\"headerlink\" title=\"组件和普通JSX语法区别\"></a>组件和普通JSX语法区别</h3><p>这个说起来也只有简单的一句话，就是你自定义的组件必须首写字母要进行大写，而JSX是小写字母开头的。</p>\n<h3 id=\"JSX使用三元运算符\"><a href=\"#JSX使用三元运算符\" class=\"headerlink\" title=\"JSX使用三元运算符\"></a>JSX使用三元运算符</h3><p>在JSX中也是可以使用js语法的，我们先简单讲解一个三元元算符的方法。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">React</span> from <span class=\"symbol\">'reac</span>t'</span><br><span class=\"line\">const <span class=\"type\">Component</span> = <span class=\"type\">React</span>.<span class=\"type\">Component</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;ul className=<span class=\"string\">\"my-list\"</span>&gt;</span><br><span class=\"line\">                &lt;li&gt;&#123;<span class=\"literal\">false</span>?<span class=\"symbol\">'zhaohui58</span>.cn':<span class=\"symbol\">'Sunshin</span>e'&#125;&lt;/li&gt;</span><br><span class=\"line\">                &lt;li&gt;<span class=\"type\">I</span> love <span class=\"type\">React</span>&lt;/li&gt;</span><br><span class=\"line\">            &lt;/ul&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"type\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<p>总结：作为一个初学者对JSX有一个简单的了解</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JSX简介\"><a href=\"#JSX简介\" class=\"headerlink\" title=\"JSX简介\"></a>JSX简介</h3><blockquote>\n<p>JSX就是Javascript和XML结合的一种格式。React发明了JSX，可以方便的利用HTML语法来创建虚拟DOM，当遇到<code>&lt;</code>，JSX就当作HTML解析，遇到<code>{</code>就当JavaScript解析.</p>\n</blockquote>\n<p>比如我们写一段JSX语法</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">className</span>=<span class=\"string\">\"my-list\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>JSPang.com<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>I love React<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>比如我们以前写一段JS代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var child1 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">React</span>.</span></span>create<span class=\"constructor\">Element('<span class=\"params\">li</span>', <span class=\"params\">null</span>, 'JSPang.<span class=\"params\">com</span>')</span>;</span><br><span class=\"line\">var child2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">React</span>.</span></span>create<span class=\"constructor\">Element('<span class=\"params\">li</span>', <span class=\"params\">null</span>, 'I <span class=\"params\">love</span> React')</span>;</span><br><span class=\"line\">var root = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">React</span>.</span></span>create<span class=\"constructor\">Element('<span class=\"params\">ul</span>', &#123; <span class=\"params\">className</span>: '<span class=\"params\">my</span>-<span class=\"params\">list</span>' &#125;, <span class=\"params\">child1</span>, <span class=\"params\">child2</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>从代码量上就可以看出JSX语法大量简化了我们的工作。</p>\n<h3 id=\"组件和普通JSX语法区别\"><a href=\"#组件和普通JSX语法区别\" class=\"headerlink\" title=\"组件和普通JSX语法区别\"></a>组件和普通JSX语法区别</h3><p>这个说起来也只有简单的一句话，就是你自定义的组件必须首写字母要进行大写，而JSX是小写字母开头的。</p>\n<h3 id=\"JSX使用三元运算符\"><a href=\"#JSX使用三元运算符\" class=\"headerlink\" title=\"JSX使用三元运算符\"></a>JSX使用三元运算符</h3><p>在JSX中也是可以使用js语法的，我们先简单讲解一个三元元算符的方法。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">React</span> from <span class=\"symbol\">'reac</span>t'</span><br><span class=\"line\">const <span class=\"type\">Component</span> = <span class=\"type\">React</span>.<span class=\"type\">Component</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;ul className=<span class=\"string\">\"my-list\"</span>&gt;</span><br><span class=\"line\">                &lt;li&gt;&#123;<span class=\"literal\">false</span>?<span class=\"symbol\">'zhaohui58</span>.cn':<span class=\"symbol\">'Sunshin</span>e'&#125;&lt;/li&gt;</span><br><span class=\"line\">                &lt;li&gt;<span class=\"type\">I</span> love <span class=\"type\">React</span>&lt;/li&gt;</span><br><span class=\"line\">            &lt;/ul&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"type\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<p>总结：作为一个初学者对JSX有一个简单的了解</p>\n"},{"title":"React进阶——JSX踩坑的几个地方","date":"2020-05-27T08:28:49.000Z","_content":"\n### JSX代码注释\n\n`JSX`中的代码注释是非常有讲究的，这个书上介绍的也非常少，所以在这里讲一下，因为在初学`React`在这里踩过坑。\n\n第一次写`JSX`注释，是直接这样写的，当然这样写是完全不对的。\n\n```\n<Fragment>\n    //第一次写注释，这个是错误的\n    <div>\n        <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n        <button onClick={this.addList.bind(this)}> 增加项目 </button>\n    </div>\n```\n\n那写`JSX`的注释，可以有下面两种写法:\n\n```\n<Fragment>\n    {/* 正确注释的写法 */}\n    <div>\n        <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n        <button onClick={this.addList.bind(this)}> 增加项目 </button>\n    </div>\n```\n\n如果你记不住，有个简单的方法，就是用`VSCode`的快捷键，直接按`Ctrl+/`，就会自动生成正确的注释了。\n\n你可以把这个理解为，在jsx中写javascript代码。所以外出我们套入了`{}`，然后里边就是一个多行的javascript注释。如果你要使用单行祝注释`//`，你需要把代码写成下面这样。\n\n```\n<Fragment>\n    {\n        //正确注释的写法 \n    }\n    <div>\n        <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n        <button onClick={this.addList.bind(this)}> 增加项目 </button>\n    </div>\n```\n\n也就是你要进行换行，所以个人认为这种方法不太优雅，所以推荐第一种注释方法。\n\n### JSX中的class陷阱\n\nreact中要把`class`换成`className`，它是防止和`js`中的`class`类名 冲突，所以要求换掉。这也算是一个小坑吧。\n\n### JSX中的html解析问题\n\n如果想在文本框里输入一个``标签，并进行渲染。默认是不会生效的，只会把``标签打印到页面上，这并不是我想要的。如果工作中有这种需求，可以使用`dangerouslySetInnerHTML`属性解决。具体代码如下：\n\n```\n<ul>\n    {\n        this.state.list.map((item,index)=>{\n            return (\n                <li \n                    key={index+item}\n                    onClick={this.deleteItem.bind(this,index)}\n                    dangerouslySetInnerHTML={{__html:item}}\n                >\n                </li>\n            )\n        })\n    }\n</ul> \n```\n\n上面的代码就可以实现`html`格式的输出。\n\nJSX中label标签的坑\n\nJSX中``的坑，也算是比较大的一个坑，label是`html`中的一个辅助标签，也是非常有用的一个标签。\n\n先看下面的代码，我们在文本框前面加入一个``。\n\n```\n<div>\n    <label>加入项目：</label>\n    <input className=\"input\" value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n    <button onClick={this.addList.bind(this)}> 增加项目 </button>\n</div>\n```\n\n这时候想点击“加入项目”直接可以激活文本框，方便输入。按照`html`的原思想，是直接加ID就可以了。代码如下：\n\n```\n<div>\n    <label for=\"Sunshine\">加入项目：</label>\n    <input id=\"Sunshine\" className=\"input\" value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n    <button onClick={this.addList.bind(this)}> 增加项目 </button>\n</div>\n```\n\n这时候你浏览效果虽然可以正常，但`console`里还是有红色警告提示的。大概意思是不能使用`for`.它容易和javascript里的for循环混淆，会提示你使用`htmlfor`。\n\n```\n<div>\n    <label htmlFor=\"Sunshine\">加入项目：</label>\n    <input id=\"Sunshine\" className=\"input\" value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n    <button onClick={this.addList.bind(this)}> 增加项目 </button>\n</div>\n```\n\n这时候代码就正确了，可以实现点击后,激活标签了。\n\n这节算是我总结的一些`JSX`中的坑吧，总结出来，希望小伙伴们少踩这些坑，能快速上手`React`。","source":"_posts/react-09.md","raw":"---\ntitle: React进阶——JSX踩坑的几个地方\ndate: 2020-05-27 16:28:49\ntags:\ncategories: react\n---\n\n### JSX代码注释\n\n`JSX`中的代码注释是非常有讲究的，这个书上介绍的也非常少，所以在这里讲一下，因为在初学`React`在这里踩过坑。\n\n第一次写`JSX`注释，是直接这样写的，当然这样写是完全不对的。\n\n```\n<Fragment>\n    //第一次写注释，这个是错误的\n    <div>\n        <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n        <button onClick={this.addList.bind(this)}> 增加项目 </button>\n    </div>\n```\n\n那写`JSX`的注释，可以有下面两种写法:\n\n```\n<Fragment>\n    {/* 正确注释的写法 */}\n    <div>\n        <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n        <button onClick={this.addList.bind(this)}> 增加项目 </button>\n    </div>\n```\n\n如果你记不住，有个简单的方法，就是用`VSCode`的快捷键，直接按`Ctrl+/`，就会自动生成正确的注释了。\n\n你可以把这个理解为，在jsx中写javascript代码。所以外出我们套入了`{}`，然后里边就是一个多行的javascript注释。如果你要使用单行祝注释`//`，你需要把代码写成下面这样。\n\n```\n<Fragment>\n    {\n        //正确注释的写法 \n    }\n    <div>\n        <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n        <button onClick={this.addList.bind(this)}> 增加项目 </button>\n    </div>\n```\n\n也就是你要进行换行，所以个人认为这种方法不太优雅，所以推荐第一种注释方法。\n\n### JSX中的class陷阱\n\nreact中要把`class`换成`className`，它是防止和`js`中的`class`类名 冲突，所以要求换掉。这也算是一个小坑吧。\n\n### JSX中的html解析问题\n\n如果想在文本框里输入一个``标签，并进行渲染。默认是不会生效的，只会把``标签打印到页面上，这并不是我想要的。如果工作中有这种需求，可以使用`dangerouslySetInnerHTML`属性解决。具体代码如下：\n\n```\n<ul>\n    {\n        this.state.list.map((item,index)=>{\n            return (\n                <li \n                    key={index+item}\n                    onClick={this.deleteItem.bind(this,index)}\n                    dangerouslySetInnerHTML={{__html:item}}\n                >\n                </li>\n            )\n        })\n    }\n</ul> \n```\n\n上面的代码就可以实现`html`格式的输出。\n\nJSX中label标签的坑\n\nJSX中``的坑，也算是比较大的一个坑，label是`html`中的一个辅助标签，也是非常有用的一个标签。\n\n先看下面的代码，我们在文本框前面加入一个``。\n\n```\n<div>\n    <label>加入项目：</label>\n    <input className=\"input\" value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n    <button onClick={this.addList.bind(this)}> 增加项目 </button>\n</div>\n```\n\n这时候想点击“加入项目”直接可以激活文本框，方便输入。按照`html`的原思想，是直接加ID就可以了。代码如下：\n\n```\n<div>\n    <label for=\"Sunshine\">加入项目：</label>\n    <input id=\"Sunshine\" className=\"input\" value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n    <button onClick={this.addList.bind(this)}> 增加项目 </button>\n</div>\n```\n\n这时候你浏览效果虽然可以正常，但`console`里还是有红色警告提示的。大概意思是不能使用`for`.它容易和javascript里的for循环混淆，会提示你使用`htmlfor`。\n\n```\n<div>\n    <label htmlFor=\"Sunshine\">加入项目：</label>\n    <input id=\"Sunshine\" className=\"input\" value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n    <button onClick={this.addList.bind(this)}> 增加项目 </button>\n</div>\n```\n\n这时候代码就正确了，可以实现点击后,激活标签了。\n\n这节算是我总结的一些`JSX`中的坑吧，总结出来，希望小伙伴们少踩这些坑，能快速上手`React`。","slug":"react-09","published":1,"updated":"2020-05-27T08:42:51.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6ao0009xy0i6sltgka5","content":"<h3 id=\"JSX代码注释\"><a href=\"#JSX代码注释\" class=\"headerlink\" title=\"JSX代码注释\"></a>JSX代码注释</h3><p><code>JSX</code>中的代码注释是非常有讲究的，这个书上介绍的也非常少，所以在这里讲一下，因为在初学<code>React</code>在这里踩过坑。</p>\n<p>第一次写<code>JSX</code>注释，是直接这样写的，当然这样写是完全不对的。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Fragment&gt;</span><br><span class=\"line\">    <span class=\"comment\">//第一次写注释，这个是错误的</span></span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.addList.bind(<span class=\"keyword\">this</span>)&#125;&gt; 增加项目 &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>那写<code>JSX</code>的注释，可以有下面两种写法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Fragment&gt;</span><br><span class=\"line\">    &#123;<span class=\"comment\">/* 正确注释的写法 */</span>&#125;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.addList.bind(<span class=\"keyword\">this</span>)&#125;&gt; 增加项目 &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果你记不住，有个简单的方法，就是用<code>VSCode</code>的快捷键，直接按<code>Ctrl+/</code>，就会自动生成正确的注释了。</p>\n<p>你可以把这个理解为，在jsx中写javascript代码。所以外出我们套入了<code>{}</code>，然后里边就是一个多行的javascript注释。如果你要使用单行祝注释<code>//</code>，你需要把代码写成下面这样。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Fragment&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//正确注释的写法 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.addList.bind(<span class=\"keyword\">this</span>)&#125;&gt; 增加项目 &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>也就是你要进行换行，所以个人认为这种方法不太优雅，所以推荐第一种注释方法。</p>\n<h3 id=\"JSX中的class陷阱\"><a href=\"#JSX中的class陷阱\" class=\"headerlink\" title=\"JSX中的class陷阱\"></a>JSX中的class陷阱</h3><p>react中要把<code>class</code>换成<code>className</code>，它是防止和<code>js</code>中的<code>class</code>类名 冲突，所以要求换掉。这也算是一个小坑吧。</p>\n<h3 id=\"JSX中的html解析问题\"><a href=\"#JSX中的html解析问题\" class=\"headerlink\" title=\"JSX中的html解析问题\"></a>JSX中的html解析问题</h3><p>如果想在文本框里输入一个<code>标签，并进行渲染。默认是不会生效的，只会把</code>标签打印到页面上，这并不是我想要的。如果工作中有这种需求，可以使用<code>dangerouslySetInnerHTML</code>属性解决。具体代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state.list.map(<span class=\"function\">(<span class=\"params\">item,index</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;li </span><br><span class=\"line\">                    key=&#123;index+item&#125;</span><br><span class=\"line\">                    onClick=&#123;<span class=\"keyword\">this</span>.deleteItem.bind(<span class=\"keyword\">this</span>,index)&#125;</span><br><span class=\"line\">                    dangerouslySetInnerHTML=&#123;&#123;<span class=\"attr\">__html</span>:item&#125;&#125;</span><br><span class=\"line\">                &gt;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            )</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就可以实现<code>html</code>格式的输出。</p>\n<p>JSX中label标签的坑</p>\n<p>JSX中``的坑，也算是比较大的一个坑，label是<code>html</code>中的一个辅助标签，也是非常有用的一个标签。</p>\n<p>先看下面的代码，我们在文本框前面加入一个``。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>加入项目：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">className</span>=<span class=\"string\">\"input\"</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.inputValue&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.inputChange.bind(this)&#125;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.addList.bind(this)&#125;</span>&gt;</span> 增加项目 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候想点击“加入项目”直接可以激活文本框，方便输入。按照<code>html</code>的原思想，是直接加ID就可以了。代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"Sunshine\"</span>&gt;</span>加入项目：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"Sunshine\"</span> <span class=\"attr\">className</span>=<span class=\"string\">\"input\"</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.inputValue&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.inputChange.bind(this)&#125;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.addList.bind(this)&#125;</span>&gt;</span> 增加项目 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候你浏览效果虽然可以正常，但<code>console</code>里还是有红色警告提示的。大概意思是不能使用<code>for</code>.它容易和javascript里的for循环混淆，会提示你使用<code>htmlfor</code>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">htmlFor</span>=<span class=\"string\">\"Sunshine\"</span>&gt;</span>加入项目：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"Sunshine\"</span> <span class=\"attr\">className</span>=<span class=\"string\">\"input\"</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.inputValue&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.inputChange.bind(this)&#125;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.addList.bind(this)&#125;</span>&gt;</span> 增加项目 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候代码就正确了，可以实现点击后,激活标签了。</p>\n<p>这节算是我总结的一些<code>JSX</code>中的坑吧，总结出来，希望小伙伴们少踩这些坑，能快速上手<code>React</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JSX代码注释\"><a href=\"#JSX代码注释\" class=\"headerlink\" title=\"JSX代码注释\"></a>JSX代码注释</h3><p><code>JSX</code>中的代码注释是非常有讲究的，这个书上介绍的也非常少，所以在这里讲一下，因为在初学<code>React</code>在这里踩过坑。</p>\n<p>第一次写<code>JSX</code>注释，是直接这样写的，当然这样写是完全不对的。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Fragment&gt;</span><br><span class=\"line\">    <span class=\"comment\">//第一次写注释，这个是错误的</span></span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.addList.bind(<span class=\"keyword\">this</span>)&#125;&gt; 增加项目 &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>那写<code>JSX</code>的注释，可以有下面两种写法:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Fragment&gt;</span><br><span class=\"line\">    &#123;<span class=\"comment\">/* 正确注释的写法 */</span>&#125;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.addList.bind(<span class=\"keyword\">this</span>)&#125;&gt; 增加项目 &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果你记不住，有个简单的方法，就是用<code>VSCode</code>的快捷键，直接按<code>Ctrl+/</code>，就会自动生成正确的注释了。</p>\n<p>你可以把这个理解为，在jsx中写javascript代码。所以外出我们套入了<code>{}</code>，然后里边就是一个多行的javascript注释。如果你要使用单行祝注释<code>//</code>，你需要把代码写成下面这样。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Fragment&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//正确注释的写法 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.addList.bind(<span class=\"keyword\">this</span>)&#125;&gt; 增加项目 &lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>也就是你要进行换行，所以个人认为这种方法不太优雅，所以推荐第一种注释方法。</p>\n<h3 id=\"JSX中的class陷阱\"><a href=\"#JSX中的class陷阱\" class=\"headerlink\" title=\"JSX中的class陷阱\"></a>JSX中的class陷阱</h3><p>react中要把<code>class</code>换成<code>className</code>，它是防止和<code>js</code>中的<code>class</code>类名 冲突，所以要求换掉。这也算是一个小坑吧。</p>\n<h3 id=\"JSX中的html解析问题\"><a href=\"#JSX中的html解析问题\" class=\"headerlink\" title=\"JSX中的html解析问题\"></a>JSX中的html解析问题</h3><p>如果想在文本框里输入一个<code>标签，并进行渲染。默认是不会生效的，只会把</code>标签打印到页面上，这并不是我想要的。如果工作中有这种需求，可以使用<code>dangerouslySetInnerHTML</code>属性解决。具体代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state.list.map(<span class=\"function\">(<span class=\"params\">item,index</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;li </span><br><span class=\"line\">                    key=&#123;index+item&#125;</span><br><span class=\"line\">                    onClick=&#123;<span class=\"keyword\">this</span>.deleteItem.bind(<span class=\"keyword\">this</span>,index)&#125;</span><br><span class=\"line\">                    dangerouslySetInnerHTML=&#123;&#123;<span class=\"attr\">__html</span>:item&#125;&#125;</span><br><span class=\"line\">                &gt;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            )</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就可以实现<code>html</code>格式的输出。</p>\n<p>JSX中label标签的坑</p>\n<p>JSX中``的坑，也算是比较大的一个坑，label是<code>html</code>中的一个辅助标签，也是非常有用的一个标签。</p>\n<p>先看下面的代码，我们在文本框前面加入一个``。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>加入项目：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">className</span>=<span class=\"string\">\"input\"</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.inputValue&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.inputChange.bind(this)&#125;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.addList.bind(this)&#125;</span>&gt;</span> 增加项目 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候想点击“加入项目”直接可以激活文本框，方便输入。按照<code>html</code>的原思想，是直接加ID就可以了。代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"Sunshine\"</span>&gt;</span>加入项目：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"Sunshine\"</span> <span class=\"attr\">className</span>=<span class=\"string\">\"input\"</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.inputValue&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.inputChange.bind(this)&#125;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.addList.bind(this)&#125;</span>&gt;</span> 增加项目 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候你浏览效果虽然可以正常，但<code>console</code>里还是有红色警告提示的。大概意思是不能使用<code>for</code>.它容易和javascript里的for循环混淆，会提示你使用<code>htmlfor</code>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">htmlFor</span>=<span class=\"string\">\"Sunshine\"</span>&gt;</span>加入项目：<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"Sunshine\"</span> <span class=\"attr\">className</span>=<span class=\"string\">\"input\"</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.inputValue&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.inputChange.bind(this)&#125;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.addList.bind(this)&#125;</span>&gt;</span> 增加项目 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候代码就正确了，可以实现点击后,激活标签了。</p>\n<p>这节算是我总结的一些<code>JSX</code>中的坑吧，总结出来，希望小伙伴们少踩这些坑，能快速上手<code>React</code>。</p>\n"},{"title":"React响应式设计原理和数据绑定","date":"2020-05-27T08:10:16.000Z","_content":"\n### 响应式设计和数据绑定\n\n`React`不建议你直接操作`DOM`元素,而是要通过数据进行驱动，改变界面中的效果。React会根据数据的变化，自动的帮助你完成界面的改变。所以在写React代码时，你无需关注DOM相关的操作，只需要关注数据的操作就可以了（这也是React如此受欢迎的主要原因，大大加快了我们的开发速度）。\n\n数据定义一般放在构造函数里`constructor`\n\n```\n//js的构造函数，由于其他任何函数执行\nconstructor(props){\n    super(props) //调用父类的构造函数，固定写法\n    this.state={\n        inputValue:'' , // input中的值\n        list:[]    //服务列表\n    }\n}\n```\n\n在`React`中的数据绑定和`Vue`中几乎一样，也是采用`字面量`(我自己起的名字)的形式，就是使用`{}`来标注，其实这也算是js代码的一种声明。比如现在我们要把`inputValue`值绑定到`input`框中，只要写入下面的代码就可以了。其实说白了就是在JSX中使用js代码。\n\n```\n<input value={this.state.inputValue} /> \n```\n\n现在需要看一下是不是可以实现绑定效果，所以把`inputValue`赋予一个'Sunshine'，然后预览看一下效果。在这里我们并没有进行任何的`DOM`操作，但是界面已经发生了变化，这些都时`React`帮我们作的，它还会自动感知数据的变化。\n\n### 绑定事件\n\n这时候你到界面的文本框中去输入值，是没有任何变化的，这是因为我们强制绑定了`inputValue`的值。如果要想改变，需要绑定**响应事件**，改变`inputValue`的值。比如绑定一个改变事件，这个事件执行`inputChange()`(当然这个方法还没有)方法。\n\n```\n<input value={this.state.inputValue} onChange={this.inputChange} />\n```\n\n现在还没有`inputChange()`这个方法，在`render()`方法的下面建立一个`inputChange()`方法，代码如下：\n\n```\ninputChange(e){\n    console.log(e.target.value);\n}\n```\n\n这时候控制台是可以打印出输入的值的。看到获得了输入的值，想当然的认为直接改变`inputValue`的值就可以了(错的).\n\n```\ninputChange(e){\n    console.log(e.target.value);\n    this.state.inputValue=e.target.value;\n}\n```\n\n写完后再进行预览，会发现程序直接报错了（加项服务还真的有点难度...........）。\n\n其实我们范了两个错误：\n\n1. 一个是`this`指向不对，你需要重新用`bind`设置一下指向(ES6的语法)。\n2. 另一个是`React`中改变值需要使用`this.setState`方法。\n\n第一个错误很好解决，直接再`JSX`部分，利用`bind`进行绑定就好。\n\n```\n <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n```\n\n这步做完，我们还需要加入`setState`方法，改变值。代码如下:\n\n```\ninputChange(e){\n    // console.log(e.target.value);\n    // this.state.inputValue=e.target.value;\n    this.setState({\n        inputValue:e.target.value\n    })\n}\n```\n\n现在测试一下，输入框可以改变值了，里边设计了`React`的重要思想。","source":"_posts/react-07.md","raw":"---\ntitle: React响应式设计原理和数据绑定\ndate: 2020-05-27 16:10:16\ntags:\ncategories: react\n---\n\n### 响应式设计和数据绑定\n\n`React`不建议你直接操作`DOM`元素,而是要通过数据进行驱动，改变界面中的效果。React会根据数据的变化，自动的帮助你完成界面的改变。所以在写React代码时，你无需关注DOM相关的操作，只需要关注数据的操作就可以了（这也是React如此受欢迎的主要原因，大大加快了我们的开发速度）。\n\n数据定义一般放在构造函数里`constructor`\n\n```\n//js的构造函数，由于其他任何函数执行\nconstructor(props){\n    super(props) //调用父类的构造函数，固定写法\n    this.state={\n        inputValue:'' , // input中的值\n        list:[]    //服务列表\n    }\n}\n```\n\n在`React`中的数据绑定和`Vue`中几乎一样，也是采用`字面量`(我自己起的名字)的形式，就是使用`{}`来标注，其实这也算是js代码的一种声明。比如现在我们要把`inputValue`值绑定到`input`框中，只要写入下面的代码就可以了。其实说白了就是在JSX中使用js代码。\n\n```\n<input value={this.state.inputValue} /> \n```\n\n现在需要看一下是不是可以实现绑定效果，所以把`inputValue`赋予一个'Sunshine'，然后预览看一下效果。在这里我们并没有进行任何的`DOM`操作，但是界面已经发生了变化，这些都时`React`帮我们作的，它还会自动感知数据的变化。\n\n### 绑定事件\n\n这时候你到界面的文本框中去输入值，是没有任何变化的，这是因为我们强制绑定了`inputValue`的值。如果要想改变，需要绑定**响应事件**，改变`inputValue`的值。比如绑定一个改变事件，这个事件执行`inputChange()`(当然这个方法还没有)方法。\n\n```\n<input value={this.state.inputValue} onChange={this.inputChange} />\n```\n\n现在还没有`inputChange()`这个方法，在`render()`方法的下面建立一个`inputChange()`方法，代码如下：\n\n```\ninputChange(e){\n    console.log(e.target.value);\n}\n```\n\n这时候控制台是可以打印出输入的值的。看到获得了输入的值，想当然的认为直接改变`inputValue`的值就可以了(错的).\n\n```\ninputChange(e){\n    console.log(e.target.value);\n    this.state.inputValue=e.target.value;\n}\n```\n\n写完后再进行预览，会发现程序直接报错了（加项服务还真的有点难度...........）。\n\n其实我们范了两个错误：\n\n1. 一个是`this`指向不对，你需要重新用`bind`设置一下指向(ES6的语法)。\n2. 另一个是`React`中改变值需要使用`this.setState`方法。\n\n第一个错误很好解决，直接再`JSX`部分，利用`bind`进行绑定就好。\n\n```\n <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n```\n\n这步做完，我们还需要加入`setState`方法，改变值。代码如下:\n\n```\ninputChange(e){\n    // console.log(e.target.value);\n    // this.state.inputValue=e.target.value;\n    this.setState({\n        inputValue:e.target.value\n    })\n}\n```\n\n现在测试一下，输入框可以改变值了，里边设计了`React`的重要思想。","slug":"react-07","published":1,"updated":"2020-05-27T08:19:40.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6ap000axy0id7np0yg9","content":"<h3 id=\"响应式设计和数据绑定\"><a href=\"#响应式设计和数据绑定\" class=\"headerlink\" title=\"响应式设计和数据绑定\"></a>响应式设计和数据绑定</h3><p><code>React</code>不建议你直接操作<code>DOM</code>元素,而是要通过数据进行驱动，改变界面中的效果。React会根据数据的变化，自动的帮助你完成界面的改变。所以在写React代码时，你无需关注DOM相关的操作，只需要关注数据的操作就可以了（这也是React如此受欢迎的主要原因，大大加快了我们的开发速度）。</p>\n<p>数据定义一般放在构造函数里<code>constructor</code></p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//js的构造函数，由于其他任何函数执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constructor</span><span class=\"params\">(props)</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    super(props) //调用父类的构造函数，固定写法</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    this.state=&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        inputValue:'' , // input中的值</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        list:[]    //服务列表</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在<code>React</code>中的数据绑定和<code>Vue</code>中几乎一样，也是采用<code>字面量</code>(我自己起的名字)的形式，就是使用<code>{}</code>来标注，其实这也算是js代码的一种声明。比如现在我们要把<code>inputValue</code>值绑定到<code>input</code>框中，只要写入下面的代码就可以了。其实说白了就是在JSX中使用js代码。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.inputValue&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在需要看一下是不是可以实现绑定效果，所以把<code>inputValue</code>赋予一个’Sunshine’，然后预览看一下效果。在这里我们并没有进行任何的<code>DOM</code>操作，但是界面已经发生了变化，这些都时<code>React</code>帮我们作的，它还会自动感知数据的变化。</p>\n<h3 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h3><p>这时候你到界面的文本框中去输入值，是没有任何变化的，这是因为我们强制绑定了<code>inputValue</code>的值。如果要想改变，需要绑定<strong>响应事件</strong>，改变<code>inputValue</code>的值。比如绑定一个改变事件，这个事件执行<code>inputChange()</code>(当然这个方法还没有)方法。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>现在还没有<code>inputChange()</code>这个方法，在<code>render()</code>方法的下面建立一个<code>inputChange()</code>方法，代码如下：</p>\n<figure class=\"highlight stan\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputChange(<span class=\"built_in\">e</span>)&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">e</span>.<span class=\"built_in\">target</span>.value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候控制台是可以打印出输入的值的。看到获得了输入的值，想当然的认为直接改变<code>inputValue</code>的值就可以了(错的).</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputChange(e)&#123;</span><br><span class=\"line\">    console.<span class=\"keyword\">log</span>(e.target.value);</span><br><span class=\"line\">    this.<span class=\"keyword\">state</span>.inputValue=e.target.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>写完后再进行预览，会发现程序直接报错了（加项服务还真的有点难度………..）。</p>\n<p>其实我们范了两个错误：</p>\n<ol>\n<li>一个是<code>this</code>指向不对，你需要重新用<code>bind</code>设置一下指向(ES6的语法)。</li>\n<li>另一个是<code>React</code>中改变值需要使用<code>this.setState</code>方法。</li>\n</ol>\n<p>第一个错误很好解决，直接再<code>JSX</code>部分，利用<code>bind</code>进行绑定就好。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这步做完，我们还需要加入<code>setState</code>方法，改变值。代码如下:</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputChange(e)&#123;</span><br><span class=\"line\">    // console.<span class=\"built_in\">log</span>(e.<span class=\"keyword\">target</span>.<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    // this.state.inputValue=e.<span class=\"keyword\">target</span>.<span class=\"keyword\">value</span>;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        inputValue:e.<span class=\"keyword\">target</span>.<span class=\"keyword\">value</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在测试一下，输入框可以改变值了，里边设计了<code>React</code>的重要思想。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"响应式设计和数据绑定\"><a href=\"#响应式设计和数据绑定\" class=\"headerlink\" title=\"响应式设计和数据绑定\"></a>响应式设计和数据绑定</h3><p><code>React</code>不建议你直接操作<code>DOM</code>元素,而是要通过数据进行驱动，改变界面中的效果。React会根据数据的变化，自动的帮助你完成界面的改变。所以在写React代码时，你无需关注DOM相关的操作，只需要关注数据的操作就可以了（这也是React如此受欢迎的主要原因，大大加快了我们的开发速度）。</p>\n<p>数据定义一般放在构造函数里<code>constructor</code></p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//js的构造函数，由于其他任何函数执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">constructor</span><span class=\"params\">(props)</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    super(props) //调用父类的构造函数，固定写法</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    this.state=&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        inputValue:'' , // input中的值</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        list:[]    //服务列表</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在<code>React</code>中的数据绑定和<code>Vue</code>中几乎一样，也是采用<code>字面量</code>(我自己起的名字)的形式，就是使用<code>{}</code>来标注，其实这也算是js代码的一种声明。比如现在我们要把<code>inputValue</code>值绑定到<code>input</code>框中，只要写入下面的代码就可以了。其实说白了就是在JSX中使用js代码。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.inputValue&#125;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在需要看一下是不是可以实现绑定效果，所以把<code>inputValue</code>赋予一个’Sunshine’，然后预览看一下效果。在这里我们并没有进行任何的<code>DOM</code>操作，但是界面已经发生了变化，这些都时<code>React</code>帮我们作的，它还会自动感知数据的变化。</p>\n<h3 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h3><p>这时候你到界面的文本框中去输入值，是没有任何变化的，这是因为我们强制绑定了<code>inputValue</code>的值。如果要想改变，需要绑定<strong>响应事件</strong>，改变<code>inputValue</code>的值。比如绑定一个改变事件，这个事件执行<code>inputChange()</code>(当然这个方法还没有)方法。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>现在还没有<code>inputChange()</code>这个方法，在<code>render()</code>方法的下面建立一个<code>inputChange()</code>方法，代码如下：</p>\n<figure class=\"highlight stan\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputChange(<span class=\"built_in\">e</span>)&#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"built_in\">e</span>.<span class=\"built_in\">target</span>.value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候控制台是可以打印出输入的值的。看到获得了输入的值，想当然的认为直接改变<code>inputValue</code>的值就可以了(错的).</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputChange(e)&#123;</span><br><span class=\"line\">    console.<span class=\"keyword\">log</span>(e.target.value);</span><br><span class=\"line\">    this.<span class=\"keyword\">state</span>.inputValue=e.target.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>写完后再进行预览，会发现程序直接报错了（加项服务还真的有点难度………..）。</p>\n<p>其实我们范了两个错误：</p>\n<ol>\n<li>一个是<code>this</code>指向不对，你需要重新用<code>bind</code>设置一下指向(ES6的语法)。</li>\n<li>另一个是<code>React</code>中改变值需要使用<code>this.setState</code>方法。</li>\n</ol>\n<p>第一个错误很好解决，直接再<code>JSX</code>部分，利用<code>bind</code>进行绑定就好。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input value=&#123;<span class=\"keyword\">this</span>.state.inputValue&#125; onChange=&#123;<span class=\"keyword\">this</span>.inputChange.bind(<span class=\"keyword\">this</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这步做完，我们还需要加入<code>setState</code>方法，改变值。代码如下:</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputChange(e)&#123;</span><br><span class=\"line\">    // console.<span class=\"built_in\">log</span>(e.<span class=\"keyword\">target</span>.<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    // this.state.inputValue=e.<span class=\"keyword\">target</span>.<span class=\"keyword\">value</span>;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">        inputValue:e.<span class=\"keyword\">target</span>.<span class=\"keyword\">value</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在测试一下，输入框可以改变值了，里边设计了<code>React</code>的重要思想。</p>\n"},{"title":"HelloWord 和组件的讲解","date":"2020-05-27T06:54:59.000Z","_content":"\n写下下面四行代码：\n\n```\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nReactDOM.render(<App />,document.getElementById('root'))\n```\n\n上面的代码，我们先引入了React两个必要的文件，然后引入了一个APP组件，目前这个组件还是没有的，需要一会建立。然后用React的语法把APP模块渲染到了`root` ID上面.这个rootID是在`public\\index.html`文件中的。\n\n这样入口文件就写好了，这时候就需要写APP组件了。\n\n### app组件的编写\n\n现在写一下App组件，这里我们采用最简单的写法，就输出一个`Hello Sunshine`,就可以了。\n\n```\nimport React, {Component} from 'react'\n\nclass App extends Component{\n    render(){\n        return (\n            <div>\n                Hello Sunshine\n            </div>\n        )\n    }\n}\nexport default App;\n```\n\n这里会出现一个不能理解的地方，就是：\n\n```\nimport React, {Component} from 'react'\n```\n\n这其实是ES6的语法-解构赋值，如果你分开写就比较清楚了，你可以把上面一行代码写成下面两行.\n\n```\nimport React from 'react'\nconst Component = React.Component\n```\n\n当我们这两个文件都编写完成后，可以在终端使用`npm start`命令，来看一下我们编写的结果了。\n\n**总结：**React的主要优势之一就是组件化编写，这也是现代前端开发的一种基本形式。所以我们在学习React的时候就要多用这种思想，只有不断练习，我们才能在工作中得心应手，轻松自如。小伙伴们也动手作一下吧。","source":"_posts/react-05.md","raw":"---\ntitle: HelloWord 和组件的讲解\ndate: 2020-05-27 14:54:59\ntags:\ncategories: react\n---\n\n写下下面四行代码：\n\n```\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nReactDOM.render(<App />,document.getElementById('root'))\n```\n\n上面的代码，我们先引入了React两个必要的文件，然后引入了一个APP组件，目前这个组件还是没有的，需要一会建立。然后用React的语法把APP模块渲染到了`root` ID上面.这个rootID是在`public\\index.html`文件中的。\n\n这样入口文件就写好了，这时候就需要写APP组件了。\n\n### app组件的编写\n\n现在写一下App组件，这里我们采用最简单的写法，就输出一个`Hello Sunshine`,就可以了。\n\n```\nimport React, {Component} from 'react'\n\nclass App extends Component{\n    render(){\n        return (\n            <div>\n                Hello Sunshine\n            </div>\n        )\n    }\n}\nexport default App;\n```\n\n这里会出现一个不能理解的地方，就是：\n\n```\nimport React, {Component} from 'react'\n```\n\n这其实是ES6的语法-解构赋值，如果你分开写就比较清楚了，你可以把上面一行代码写成下面两行.\n\n```\nimport React from 'react'\nconst Component = React.Component\n```\n\n当我们这两个文件都编写完成后，可以在终端使用`npm start`命令，来看一下我们编写的结果了。\n\n**总结：**React的主要优势之一就是组件化编写，这也是现代前端开发的一种基本形式。所以我们在学习React的时候就要多用这种思想，只有不断练习，我们才能在工作中得心应手，轻松自如。小伙伴们也动手作一下吧。","slug":"react-05","published":1,"updated":"2020-05-27T07:04:37.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6aq000dxy0i20v9biz3","content":"<p>写下下面四行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>,<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>))</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，我们先引入了React两个必要的文件，然后引入了一个APP组件，目前这个组件还是没有的，需要一会建立。然后用React的语法把APP模块渲染到了<code>root</code> ID上面.这个rootID是在<code>public\\index.html</code>文件中的。</p>\n<p>这样入口文件就写好了，这时候就需要写APP组件了。</p>\n<h3 id=\"app组件的编写\"><a href=\"#app组件的编写\" class=\"headerlink\" title=\"app组件的编写\"></a>app组件的编写</h3><p>现在写一下App组件，这里我们采用最简单的写法，就输出一个<code>Hello Sunshine</code>,就可以了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">React</span>, &#123;<span class=\"type\">Component</span>&#125; from <span class=\"symbol\">'reac</span>t'</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                <span class=\"type\">Hello</span> <span class=\"type\">Sunshine</span></span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"type\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里会出现一个不能理解的地方，就是：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br></pre></td></tr></table></figure>\n\n<p>这其实是ES6的语法-解构赋值，如果你分开写就比较清楚了，你可以把上面一行代码写成下面两行.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Component = React.Component</span><br></pre></td></tr></table></figure>\n\n<p>当我们这两个文件都编写完成后，可以在终端使用<code>npm start</code>命令，来看一下我们编写的结果了。</p>\n<p><strong>总结：</strong>React的主要优势之一就是组件化编写，这也是现代前端开发的一种基本形式。所以我们在学习React的时候就要多用这种思想，只有不断练习，我们才能在工作中得心应手，轻松自如。小伙伴们也动手作一下吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写下下面四行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./App'</span></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>,<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>))</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码，我们先引入了React两个必要的文件，然后引入了一个APP组件，目前这个组件还是没有的，需要一会建立。然后用React的语法把APP模块渲染到了<code>root</code> ID上面.这个rootID是在<code>public\\index.html</code>文件中的。</p>\n<p>这样入口文件就写好了，这时候就需要写APP组件了。</p>\n<h3 id=\"app组件的编写\"><a href=\"#app组件的编写\" class=\"headerlink\" title=\"app组件的编写\"></a>app组件的编写</h3><p>现在写一下App组件，这里我们采用最简单的写法，就输出一个<code>Hello Sunshine</code>,就可以了。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">React</span>, &#123;<span class=\"type\">Component</span>&#125; from <span class=\"symbol\">'reac</span>t'</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                <span class=\"type\">Hello</span> <span class=\"type\">Sunshine</span></span><br><span class=\"line\">            &lt;/div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export <span class=\"keyword\">default</span> <span class=\"type\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里会出现一个不能理解的地方，就是：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br></pre></td></tr></table></figure>\n\n<p>这其实是ES6的语法-解构赋值，如果你分开写就比较清楚了，你可以把上面一行代码写成下面两行.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Component = React.Component</span><br></pre></td></tr></table></figure>\n\n<p>当我们这两个文件都编写完成后，可以在终端使用<code>npm start</code>命令，来看一下我们编写的结果了。</p>\n<p><strong>总结：</strong>React的主要优势之一就是组件化编写，这也是现代前端开发的一种基本形式。所以我们在学习React的时候就要多用这种思想，只有不断练习，我们才能在工作中得心应手，轻松自如。小伙伴们也动手作一下吧。</p>\n"},{"title":"React实例","date":"2020-05-27T08:19:46.000Z","_content":"\n### 让列表数据化\n\n现在的列表还是写死的两个``标签，那要变成动态显示的，就需要把这个列表先进行数据化，然后再用`javascript`代码，循环在页面上。\n\n我们先给list数组增加两个数组元素，代码如下：\n\n```\nconstructor(props){\n    super(props) //调用父类的构造函数，固定写法\n    this.state={\n        inputValue:'Sunshine' , // input中的值\n        //----------主要 代码--------start\n        list:['项目一','项目二']   \n        //----------主要 代码--------end\n    }\n}\n```\n\n有了数据后，可以在`JSX`部分进行循环输出，代码如下：\n\n```\nrender(){\n    return  (\n        <Fragment>\n            <div>\n                <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n                <button> 增加项目 </button>\n            </div>\n            <ul>\n                {\n                    this.state.list.map((item,index)=>{\n                        return <li>{item}</li>\n                    })\n                }\n            </ul>  \n        </Fragment>\n    )\n}\n```\n\n完成上面的步骤，数据就不再是固定的了，而是动态管理的，也为我们接下来的添加打下了基础，剩下的步骤也显得很简单了。\n\n### 增加服务选项\n\n要增加服务选项，我们需要再增加按钮上先绑定一个方法`this.addList`(这个方法目前还没有，需要我们接下来建立).\n\n```\n<button onClick={this.addList.bind(this)}> 增加项目 </button>\n```\n\n接下来就是把`this.addList`方法，代码如下：\n\n```\n//增加服务的按钮响应方法\naddList(){\n    this.setState({\n        list:[...this.state.list,this.state.inputValue]\n    })\n\n}\n```\n\n这里需要说的是`...`这个是ES6的新语法，叫做扩展运算符。意思就是把list数组进行了分解，形成了新的数组，然后再进行组合。这种写法更简单和直观，所以推荐这种写法。\n\n### 解决key值错误\n\n高兴的同时其实是有一些隐患的，打开浏览器的控制台`F12`,可以清楚的看到报错了。这个错误的大概意思就是缺少`key值`。就是在用map循环时，需要设置一个不同的值，这个时React的要求。我们可以暂时用`index+item`的形式来实现。\n\n```\n<ul>\n    {\n        this.state.list.map((item,index)=>{\n            return <li key={index+item}>{item}</li>\n        })\n    }\n</ul> \n```\n\n### 数组下标的传递\n\n如果要删除一个东西，就要得到数组里的一个编号，这里指下标。传递下标就要有事件产生，先来绑定一个双击事件.代码如下:\n\n```\n<ul>\n    {\n        this.state.list.map((item,index)=>{\n            return (\n                <li \n                    key={index+item}\n                    onClick={this.deleteItem.bind(this,index)}\n                >\n                    {item}\n                </li>\n            )\n        })\n    }\n</ul>  \n```\n\n为了看着更清晰，我们在`return`部分加了`()`这要就可以换行编写`JSX`代码了.在`onClick`我们绑定了`deleteItem`方法.\n\n### 编写deleteItem方法\n\n绑定做好了,现在需要把`deleteItem`,在代码的最下方,加入下面的代码.方法接受一个参数`index`.\n\n```\n//删除单项服务\ndeleteItem(index){\n    let list = this.state.list\n    list.splice(index,1)\n    this.setState({\n        list:list\n    })\n\n}\n```\n\n其实这里边是有一个坑的,有的小伙伴肯定会认为下面的代码也是正确的.\n\n```\n//删除单项服务\ndeleteItem(index){\n    this.state.list.splice(index,1)\n    this.setState({\n        list:this.state.list\n    }) \n}\n```\n\n记住React是禁止直接操作state的,虽然上面的方法也管用,但是在后期的性能优化上会有很多麻烦,所以一定不要这样操作.这也算是我`React`初期踩的比较深的一个坑,希望小伙伴们可以跳坑.\n\n","source":"_posts/react-08.md","raw":"---\ntitle: React实例\ndate: 2020-05-27 16:19:46\ntags:\ncategories: react\n---\n\n### 让列表数据化\n\n现在的列表还是写死的两个``标签，那要变成动态显示的，就需要把这个列表先进行数据化，然后再用`javascript`代码，循环在页面上。\n\n我们先给list数组增加两个数组元素，代码如下：\n\n```\nconstructor(props){\n    super(props) //调用父类的构造函数，固定写法\n    this.state={\n        inputValue:'Sunshine' , // input中的值\n        //----------主要 代码--------start\n        list:['项目一','项目二']   \n        //----------主要 代码--------end\n    }\n}\n```\n\n有了数据后，可以在`JSX`部分进行循环输出，代码如下：\n\n```\nrender(){\n    return  (\n        <Fragment>\n            <div>\n                <input value={this.state.inputValue} onChange={this.inputChange.bind(this)} />\n                <button> 增加项目 </button>\n            </div>\n            <ul>\n                {\n                    this.state.list.map((item,index)=>{\n                        return <li>{item}</li>\n                    })\n                }\n            </ul>  \n        </Fragment>\n    )\n}\n```\n\n完成上面的步骤，数据就不再是固定的了，而是动态管理的，也为我们接下来的添加打下了基础，剩下的步骤也显得很简单了。\n\n### 增加服务选项\n\n要增加服务选项，我们需要再增加按钮上先绑定一个方法`this.addList`(这个方法目前还没有，需要我们接下来建立).\n\n```\n<button onClick={this.addList.bind(this)}> 增加项目 </button>\n```\n\n接下来就是把`this.addList`方法，代码如下：\n\n```\n//增加服务的按钮响应方法\naddList(){\n    this.setState({\n        list:[...this.state.list,this.state.inputValue]\n    })\n\n}\n```\n\n这里需要说的是`...`这个是ES6的新语法，叫做扩展运算符。意思就是把list数组进行了分解，形成了新的数组，然后再进行组合。这种写法更简单和直观，所以推荐这种写法。\n\n### 解决key值错误\n\n高兴的同时其实是有一些隐患的，打开浏览器的控制台`F12`,可以清楚的看到报错了。这个错误的大概意思就是缺少`key值`。就是在用map循环时，需要设置一个不同的值，这个时React的要求。我们可以暂时用`index+item`的形式来实现。\n\n```\n<ul>\n    {\n        this.state.list.map((item,index)=>{\n            return <li key={index+item}>{item}</li>\n        })\n    }\n</ul> \n```\n\n### 数组下标的传递\n\n如果要删除一个东西，就要得到数组里的一个编号，这里指下标。传递下标就要有事件产生，先来绑定一个双击事件.代码如下:\n\n```\n<ul>\n    {\n        this.state.list.map((item,index)=>{\n            return (\n                <li \n                    key={index+item}\n                    onClick={this.deleteItem.bind(this,index)}\n                >\n                    {item}\n                </li>\n            )\n        })\n    }\n</ul>  \n```\n\n为了看着更清晰，我们在`return`部分加了`()`这要就可以换行编写`JSX`代码了.在`onClick`我们绑定了`deleteItem`方法.\n\n### 编写deleteItem方法\n\n绑定做好了,现在需要把`deleteItem`,在代码的最下方,加入下面的代码.方法接受一个参数`index`.\n\n```\n//删除单项服务\ndeleteItem(index){\n    let list = this.state.list\n    list.splice(index,1)\n    this.setState({\n        list:list\n    })\n\n}\n```\n\n其实这里边是有一个坑的,有的小伙伴肯定会认为下面的代码也是正确的.\n\n```\n//删除单项服务\ndeleteItem(index){\n    this.state.list.splice(index,1)\n    this.setState({\n        list:this.state.list\n    }) \n}\n```\n\n记住React是禁止直接操作state的,虽然上面的方法也管用,但是在后期的性能优化上会有很多麻烦,所以一定不要这样操作.这也算是我`React`初期踩的比较深的一个坑,希望小伙伴们可以跳坑.\n\n","slug":"react-08","published":1,"updated":"2020-05-27T08:33:34.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6ar000fxy0ihhrre44e","content":"<h3 id=\"让列表数据化\"><a href=\"#让列表数据化\" class=\"headerlink\" title=\"让列表数据化\"></a>让列表数据化</h3><p>现在的列表还是写死的两个``标签，那要变成动态显示的，就需要把这个列表先进行数据化，然后再用<code>javascript</code>代码，循环在页面上。</p>\n<p>我们先给list数组增加两个数组元素，代码如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(<span class=\"params\">props</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props) <span class=\"comment\">//调用父类的构造函数，固定写法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state=&#123;</span><br><span class=\"line\">        inputValue:<span class=\"string\">'Sunshine'</span> , <span class=\"comment\">// input中的值</span></span><br><span class=\"line\">        <span class=\"comment\">//----------主要 代码--------start</span></span><br><span class=\"line\">        list:[<span class=\"string\">'项目一'</span>,<span class=\"string\">'项目二'</span>]   </span><br><span class=\"line\">        <span class=\"comment\">//----------主要 代码--------end</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了数据后，可以在<code>JSX</code>部分进行循环输出，代码如下：</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  (</span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Fragment</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            </span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=</span></span><span class=\"xquery\">&#123;this.state.inputValue&#125;</span><span class=\"xml\"><span class=\"tag\"> <span class=\"attr\">onChange</span>=</span></span><span class=\"xquery\">&#123;this.inputChange.bind(this)&#125;</span><span class=\"xml\"><span class=\"tag\"> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                </span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span> 增加项目 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            </span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                </span><span class=\"xquery\">&#123;</span></span><br><span class=\"line\"><span class=\"xquery\">                    this.state.list.<span class=\"keyword\">map</span>((<span class=\"type\">item</span>,index)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"xquery\">                        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><span class=\"xquery\">&#123;<span class=\"type\">item</span>&#125;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                    &#125;)</span></span><br><span class=\"line\"><span class=\"xml\">                &#125;</span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span>  </span><br><span class=\"line\">        &lt;/Fragment&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成上面的步骤，数据就不再是固定的了，而是动态管理的，也为我们接下来的添加打下了基础，剩下的步骤也显得很简单了。</p>\n<h3 id=\"增加服务选项\"><a href=\"#增加服务选项\" class=\"headerlink\" title=\"增加服务选项\"></a>增加服务选项</h3><p>要增加服务选项，我们需要再增加按钮上先绑定一个方法<code>this.addList</code>(这个方法目前还没有，需要我们接下来建立).</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick=&#123;<span class=\"keyword\">this</span>.addList.bind(<span class=\"keyword\">this</span>)&#125;&gt; 增加项目 &lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是把<code>this.addList</code>方法，代码如下：</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//增加服务的按钮响应方法</span><br><span class=\"line\">addList()&#123;</span><br><span class=\"line\">    this.<span class=\"built_in\">set</span>State(&#123;</span><br><span class=\"line\">        list:[...this.<span class=\"keyword\">state</span>.list,this.<span class=\"keyword\">state</span>.inputValue]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要说的是<code>...</code>这个是ES6的新语法，叫做扩展运算符。意思就是把list数组进行了分解，形成了新的数组，然后再进行组合。这种写法更简单和直观，所以推荐这种写法。</p>\n<h3 id=\"解决key值错误\"><a href=\"#解决key值错误\" class=\"headerlink\" title=\"解决key值错误\"></a>解决key值错误</h3><p>高兴的同时其实是有一些隐患的，打开浏览器的控制台<code>F12</code>,可以清楚的看到报错了。这个错误的大概意思就是缺少<code>key值</code>。就是在用map循环时，需要设置一个不同的值，这个时React的要求。我们可以暂时用<code>index+item</code>的形式来实现。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"xquery\">&#123;</span></span><br><span class=\"line\"><span class=\"xquery\">        this.state.list.<span class=\"keyword\">map</span>((<span class=\"type\">item</span>,index)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"xquery\">            <span class=\"keyword\">return</span> &lt;li<span class=\"built_in\"> key</span>=&#123;index+<span class=\"type\">item</span>&#125;</span><span class=\"xml\">&gt;</span><span class=\"xquery\">&#123;<span class=\"type\">item</span>&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组下标的传递\"><a href=\"#数组下标的传递\" class=\"headerlink\" title=\"数组下标的传递\"></a>数组下标的传递</h3><p>如果要删除一个东西，就要得到数组里的一个编号，这里指下标。传递下标就要有事件产生，先来绑定一个双击事件.代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state.list.map(<span class=\"function\">(<span class=\"params\">item,index</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;li </span><br><span class=\"line\">                    key=&#123;index+item&#125;</span><br><span class=\"line\">                    onClick=&#123;<span class=\"keyword\">this</span>.deleteItem.bind(<span class=\"keyword\">this</span>,index)&#125;</span><br><span class=\"line\">                &gt;</span><br><span class=\"line\">                    &#123;item&#125;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            )</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n\n<p>为了看着更清晰，我们在<code>return</code>部分加了<code>()</code>这要就可以换行编写<code>JSX</code>代码了.在<code>onClick</code>我们绑定了<code>deleteItem</code>方法.</p>\n<h3 id=\"编写deleteItem方法\"><a href=\"#编写deleteItem方法\" class=\"headerlink\" title=\"编写deleteItem方法\"></a>编写deleteItem方法</h3><p>绑定做好了,现在需要把<code>deleteItem</code>,在代码的最下方,加入下面的代码.方法接受一个参数<code>index</code>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除单项服务</span></span><br><span class=\"line\">deleteItem(index)&#123;</span><br><span class=\"line\">    let <span class=\"built_in\">list</span> = <span class=\"keyword\">this</span>.state.<span class=\"built_in\">list</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>.splice(index,<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>:<span class=\"built_in\">list</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这里边是有一个坑的,有的小伙伴肯定会认为下面的代码也是正确的.</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//删除单项服务</span><br><span class=\"line\">deleteItem(index)&#123;</span><br><span class=\"line\">    this.<span class=\"keyword\">state</span>.list.splice(index,<span class=\"number\">1</span>)</span><br><span class=\"line\">    this.<span class=\"built_in\">set</span>State(&#123;</span><br><span class=\"line\">        list:this.<span class=\"keyword\">state</span>.list</span><br><span class=\"line\">    &#125;) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>记住React是禁止直接操作state的,虽然上面的方法也管用,但是在后期的性能优化上会有很多麻烦,所以一定不要这样操作.这也算是我<code>React</code>初期踩的比较深的一个坑,希望小伙伴们可以跳坑.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"让列表数据化\"><a href=\"#让列表数据化\" class=\"headerlink\" title=\"让列表数据化\"></a>让列表数据化</h3><p>现在的列表还是写死的两个``标签，那要变成动态显示的，就需要把这个列表先进行数据化，然后再用<code>javascript</code>代码，循环在页面上。</p>\n<p>我们先给list数组增加两个数组元素，代码如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(<span class=\"params\">props</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props) <span class=\"comment\">//调用父类的构造函数，固定写法</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state=&#123;</span><br><span class=\"line\">        inputValue:<span class=\"string\">'Sunshine'</span> , <span class=\"comment\">// input中的值</span></span><br><span class=\"line\">        <span class=\"comment\">//----------主要 代码--------start</span></span><br><span class=\"line\">        list:[<span class=\"string\">'项目一'</span>,<span class=\"string\">'项目二'</span>]   </span><br><span class=\"line\">        <span class=\"comment\">//----------主要 代码--------end</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了数据后，可以在<code>JSX</code>部分进行循环输出，代码如下：</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  (</span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Fragment</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            </span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=</span></span><span class=\"xquery\">&#123;this.state.inputValue&#125;</span><span class=\"xml\"><span class=\"tag\"> <span class=\"attr\">onChange</span>=</span></span><span class=\"xquery\">&#123;this.inputChange.bind(this)&#125;</span><span class=\"xml\"><span class=\"tag\"> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                </span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span> 增加项目 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            </span><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                </span><span class=\"xquery\">&#123;</span></span><br><span class=\"line\"><span class=\"xquery\">                    this.state.list.<span class=\"keyword\">map</span>((<span class=\"type\">item</span>,index)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"xquery\">                        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><span class=\"xquery\">&#123;<span class=\"type\">item</span>&#125;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                    &#125;)</span></span><br><span class=\"line\"><span class=\"xml\">                &#125;</span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span>  </span><br><span class=\"line\">        &lt;/Fragment&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成上面的步骤，数据就不再是固定的了，而是动态管理的，也为我们接下来的添加打下了基础，剩下的步骤也显得很简单了。</p>\n<h3 id=\"增加服务选项\"><a href=\"#增加服务选项\" class=\"headerlink\" title=\"增加服务选项\"></a>增加服务选项</h3><p>要增加服务选项，我们需要再增加按钮上先绑定一个方法<code>this.addList</code>(这个方法目前还没有，需要我们接下来建立).</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick=&#123;<span class=\"keyword\">this</span>.addList.bind(<span class=\"keyword\">this</span>)&#125;&gt; 增加项目 &lt;/button&gt;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是把<code>this.addList</code>方法，代码如下：</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//增加服务的按钮响应方法</span><br><span class=\"line\">addList()&#123;</span><br><span class=\"line\">    this.<span class=\"built_in\">set</span>State(&#123;</span><br><span class=\"line\">        list:[...this.<span class=\"keyword\">state</span>.list,this.<span class=\"keyword\">state</span>.inputValue]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要说的是<code>...</code>这个是ES6的新语法，叫做扩展运算符。意思就是把list数组进行了分解，形成了新的数组，然后再进行组合。这种写法更简单和直观，所以推荐这种写法。</p>\n<h3 id=\"解决key值错误\"><a href=\"#解决key值错误\" class=\"headerlink\" title=\"解决key值错误\"></a>解决key值错误</h3><p>高兴的同时其实是有一些隐患的，打开浏览器的控制台<code>F12</code>,可以清楚的看到报错了。这个错误的大概意思就是缺少<code>key值</code>。就是在用map循环时，需要设置一个不同的值，这个时React的要求。我们可以暂时用<code>index+item</code>的形式来实现。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"xquery\">&#123;</span></span><br><span class=\"line\"><span class=\"xquery\">        this.state.list.<span class=\"keyword\">map</span>((<span class=\"type\">item</span>,index)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"xquery\">            <span class=\"keyword\">return</span> &lt;li<span class=\"built_in\"> key</span>=&#123;index+<span class=\"type\">item</span>&#125;</span><span class=\"xml\">&gt;</span><span class=\"xquery\">&#123;<span class=\"type\">item</span>&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组下标的传递\"><a href=\"#数组下标的传递\" class=\"headerlink\" title=\"数组下标的传递\"></a>数组下标的传递</h3><p>如果要删除一个东西，就要得到数组里的一个编号，这里指下标。传递下标就要有事件产生，先来绑定一个双击事件.代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state.list.map(<span class=\"function\">(<span class=\"params\">item,index</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;li </span><br><span class=\"line\">                    key=&#123;index+item&#125;</span><br><span class=\"line\">                    onClick=&#123;<span class=\"keyword\">this</span>.deleteItem.bind(<span class=\"keyword\">this</span>,index)&#125;</span><br><span class=\"line\">                &gt;</span><br><span class=\"line\">                    &#123;item&#125;</span><br><span class=\"line\">                &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            )</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n\n<p>为了看着更清晰，我们在<code>return</code>部分加了<code>()</code>这要就可以换行编写<code>JSX</code>代码了.在<code>onClick</code>我们绑定了<code>deleteItem</code>方法.</p>\n<h3 id=\"编写deleteItem方法\"><a href=\"#编写deleteItem方法\" class=\"headerlink\" title=\"编写deleteItem方法\"></a>编写deleteItem方法</h3><p>绑定做好了,现在需要把<code>deleteItem</code>,在代码的最下方,加入下面的代码.方法接受一个参数<code>index</code>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除单项服务</span></span><br><span class=\"line\">deleteItem(index)&#123;</span><br><span class=\"line\">    let <span class=\"built_in\">list</span> = <span class=\"keyword\">this</span>.state.<span class=\"built_in\">list</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>.splice(index,<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>:<span class=\"built_in\">list</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这里边是有一个坑的,有的小伙伴肯定会认为下面的代码也是正确的.</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//删除单项服务</span><br><span class=\"line\">deleteItem(index)&#123;</span><br><span class=\"line\">    this.<span class=\"keyword\">state</span>.list.splice(index,<span class=\"number\">1</span>)</span><br><span class=\"line\">    this.<span class=\"built_in\">set</span>State(&#123;</span><br><span class=\"line\">        list:this.<span class=\"keyword\">state</span>.list</span><br><span class=\"line\">    &#125;) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>记住React是禁止直接操作state的,虽然上面的方法也管用,但是在后期的性能优化上会有很多麻烦,所以一定不要这样操作.这也算是我<code>React</code>初期踩的比较深的一个坑,希望小伙伴们可以跳坑.</p>\n"},{"title":"React进阶——安装Simple React Snippets","date":"2020-05-30T05:05:50.000Z","_content":"\n### 安装Simple React Snippets\n\n打开`VSCode`的插件查单，然后在输入框中输入`Simple React Snippets`,然后点击进行安装就可以了。\n\n\\###　快速进行引入`import`\n\n直接在`vscode`中输入`imrc`，就会快速生成最常用的import代码。\n\n```\nimport React, { Component } from 'react';\n```\n\n### 快速生成class\n\n在作组件的时候，都需要写一个固定的基本格式，这时候你就可以使用快捷键`cc`.插件就会快速帮我们生成如下代码：\n\n```\nclass  extends Component {\n    state = {  }\n    render() { \n        return (  );\n    }\n}\n\nexport default ;\n\n```\n\n还有很多快捷键，如果你需要理解，打开插件的说明文件看一下就可以了。\n\n","source":"_posts/react-10.md","raw":"---\ntitle: React进阶——安装Simple React Snippets\ndate: 2020-05-30 13:05:50\ntags:\ncategories: react\n---\n\n### 安装Simple React Snippets\n\n打开`VSCode`的插件查单，然后在输入框中输入`Simple React Snippets`,然后点击进行安装就可以了。\n\n\\###　快速进行引入`import`\n\n直接在`vscode`中输入`imrc`，就会快速生成最常用的import代码。\n\n```\nimport React, { Component } from 'react';\n```\n\n### 快速生成class\n\n在作组件的时候，都需要写一个固定的基本格式，这时候你就可以使用快捷键`cc`.插件就会快速帮我们生成如下代码：\n\n```\nclass  extends Component {\n    state = {  }\n    render() { \n        return (  );\n    }\n}\n\nexport default ;\n\n```\n\n还有很多快捷键，如果你需要理解，打开插件的说明文件看一下就可以了。\n\n","slug":"react-10","published":1,"updated":"2020-05-30T05:13:52.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6as000hxy0ieiah0nze","content":"<h3 id=\"安装Simple-React-Snippets\"><a href=\"#安装Simple-React-Snippets\" class=\"headerlink\" title=\"安装Simple React Snippets\"></a>安装Simple React Snippets</h3><p>打开<code>VSCode</code>的插件查单，然后在输入框中输入<code>Simple React Snippets</code>,然后点击进行安装就可以了。</p>\n<p>###　快速进行引入<code>import</code></p>\n<p>直接在<code>vscode</code>中输入<code>imrc</code>，就会快速生成最常用的import代码。</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速生成class\"><a href=\"#快速生成class\" class=\"headerlink\" title=\"快速生成class\"></a>快速生成class</h3><p>在作组件的时候，都需要写一个固定的基本格式，这时候你就可以使用快捷键<code>cc</code>.插件就会快速帮我们生成如下代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    state = &#123;  &#125;</span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (  );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> ;</span><br></pre></td></tr></table></figure>\n\n<p>还有很多快捷键，如果你需要理解，打开插件的说明文件看一下就可以了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装Simple-React-Snippets\"><a href=\"#安装Simple-React-Snippets\" class=\"headerlink\" title=\"安装Simple React Snippets\"></a>安装Simple React Snippets</h3><p>打开<code>VSCode</code>的插件查单，然后在输入框中输入<code>Simple React Snippets</code>,然后点击进行安装就可以了。</p>\n<p>###　快速进行引入<code>import</code></p>\n<p>直接在<code>vscode</code>中输入<code>imrc</code>，就会快速生成最常用的import代码。</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速生成class\"><a href=\"#快速生成class\" class=\"headerlink\" title=\"快速生成class\"></a>快速生成class</h3><p>在作组件的时候，都需要写一个固定的基本格式，这时候你就可以使用快捷键<code>cc</code>.插件就会快速帮我们生成如下代码：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    state = &#123;  &#125;</span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (  );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> ;</span><br></pre></td></tr></table></figure>\n\n<p>还有很多快捷键，如果你需要理解，打开插件的说明文件看一下就可以了。</p>\n"},{"title":"React进阶——单项数据流和其他","date":"2020-05-30T05:05:59.000Z","_content":"\n### React 单项数据流\n\nReact是单项数据流，数据流主要从父节点传递到子节点（通过props）\n\n如果顶层（父级）的某个props改变了，React会重渲染所有的子节点\n\n### Props：\n\n `props`是property的缩写，可以理解为HTML标签的attribute。\n\n　　不可以使用`this.props`直接修改props，因为`props是`只读的，`props`是用于整个组件树中传递数据和配置。\n\n　　在当前组件访问`props`，使用`this.props`。\n\n### State：\n\n​\t\t每个组件都有属于自己的`state`，`state`和`props`的区别在于前者(state)只存在于组件内部，只能从当前组件调用`this.setState`修改state值（不可以直接修改`this.state！`）。\n\n　　一般我们更新子组件都是通过改变`state`值，将state值通过属性传递给子组件，子组件的获取`props`值从而达到更新。\n\n### 函数式编程\n\n1. 函数式编程让我们的代码更清晰，每个功能都是一个函数。\n2. 函数式编程为我们的代码测试代理了极大的方便，更容易实现前端自动化测试。\n\n","source":"_posts/react-12.md","raw":"---\ntitle: React进阶——单项数据流和其他\ndate: 2020-05-30 13:05:59\ntags:\ncategories: react\n---\n\n### React 单项数据流\n\nReact是单项数据流，数据流主要从父节点传递到子节点（通过props）\n\n如果顶层（父级）的某个props改变了，React会重渲染所有的子节点\n\n### Props：\n\n `props`是property的缩写，可以理解为HTML标签的attribute。\n\n　　不可以使用`this.props`直接修改props，因为`props是`只读的，`props`是用于整个组件树中传递数据和配置。\n\n　　在当前组件访问`props`，使用`this.props`。\n\n### State：\n\n​\t\t每个组件都有属于自己的`state`，`state`和`props`的区别在于前者(state)只存在于组件内部，只能从当前组件调用`this.setState`修改state值（不可以直接修改`this.state！`）。\n\n　　一般我们更新子组件都是通过改变`state`值，将state值通过属性传递给子组件，子组件的获取`props`值从而达到更新。\n\n### 函数式编程\n\n1. 函数式编程让我们的代码更清晰，每个功能都是一个函数。\n2. 函数式编程为我们的代码测试代理了极大的方便，更容易实现前端自动化测试。\n\n","slug":"react-12","published":1,"updated":"2020-05-30T05:43:45.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6at000jxy0ifde8c8nv","content":"<h3 id=\"React-单项数据流\"><a href=\"#React-单项数据流\" class=\"headerlink\" title=\"React 单项数据流\"></a>React 单项数据流</h3><p>React是单项数据流，数据流主要从父节点传递到子节点（通过props）</p>\n<p>如果顶层（父级）的某个props改变了，React会重渲染所有的子节点</p>\n<h3 id=\"Props：\"><a href=\"#Props：\" class=\"headerlink\" title=\"Props：\"></a>Props：</h3><p> <code>props</code>是property的缩写，可以理解为HTML标签的attribute。</p>\n<p>　　不可以使用<code>this.props</code>直接修改props，因为<code>props是</code>只读的，<code>props</code>是用于整个组件树中传递数据和配置。</p>\n<p>　　在当前组件访问<code>props</code>，使用<code>this.props</code>。</p>\n<h3 id=\"State：\"><a href=\"#State：\" class=\"headerlink\" title=\"State：\"></a>State：</h3><p>​        每个组件都有属于自己的<code>state</code>，<code>state</code>和<code>props</code>的区别在于前者(state)只存在于组件内部，只能从当前组件调用<code>this.setState</code>修改state值（不可以直接修改<code>this.state！</code>）。</p>\n<p>　　一般我们更新子组件都是通过改变<code>state</code>值，将state值通过属性传递给子组件，子组件的获取<code>props</code>值从而达到更新。</p>\n<h3 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h3><ol>\n<li>函数式编程让我们的代码更清晰，每个功能都是一个函数。</li>\n<li>函数式编程为我们的代码测试代理了极大的方便，更容易实现前端自动化测试。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"React-单项数据流\"><a href=\"#React-单项数据流\" class=\"headerlink\" title=\"React 单项数据流\"></a>React 单项数据流</h3><p>React是单项数据流，数据流主要从父节点传递到子节点（通过props）</p>\n<p>如果顶层（父级）的某个props改变了，React会重渲染所有的子节点</p>\n<h3 id=\"Props：\"><a href=\"#Props：\" class=\"headerlink\" title=\"Props：\"></a>Props：</h3><p> <code>props</code>是property的缩写，可以理解为HTML标签的attribute。</p>\n<p>　　不可以使用<code>this.props</code>直接修改props，因为<code>props是</code>只读的，<code>props</code>是用于整个组件树中传递数据和配置。</p>\n<p>　　在当前组件访问<code>props</code>，使用<code>this.props</code>。</p>\n<h3 id=\"State：\"><a href=\"#State：\" class=\"headerlink\" title=\"State：\"></a>State：</h3><p>​        每个组件都有属于自己的<code>state</code>，<code>state</code>和<code>props</code>的区别在于前者(state)只存在于组件内部，只能从当前组件调用<code>this.setState</code>修改state值（不可以直接修改<code>this.state！</code>）。</p>\n<p>　　一般我们更新子组件都是通过改变<code>state</code>值，将state值通过属性传递给子组件，子组件的获取<code>props</code>值从而达到更新。</p>\n<h3 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h3><ol>\n<li>函数式编程让我们的代码更清晰，每个功能都是一个函数。</li>\n<li>函数式编程为我们的代码测试代理了极大的方便，更容易实现前端自动化测试。</li>\n</ol>\n"},{"title":"React进阶——父子组件的传值","date":"2020-05-30T05:05:56.000Z","_content":"\n### 父组件向子组件传值\n\n这里只介绍最实用的，最快速的上手方法。就是使用组件属性的形式父组件给子组件传值。比如：我们在`<sunshineItem>组件中加入content`属性，然后给属性传递`{item}`，这样就完成了父组件向子组件传值。\n\n```\n<sunshineItem content={item}/>\n```\n\n现在值已经顺利的传递了过去，这时候可以通过`this.props.xxx`的形式进行接受，比如传递过来的值，可以用如下代码进行接收。\n\n```\nimport React, { Component } from 'react'; //imrc\nclass sunshineItem  extends Component { //cc\n\n    render() { \n        return ( \n            <div>{this.props.content}</div>\n         );\n    }\n}\n\nexport default sunshineItem;\n```\n\n### 子组件向父组件传递数据\n\n现在要作这样一个功能：点击组件中的菜单项后，删除改菜单项。在前边的课程中已经学习了这个知识，知识现在组件拆分了，就涉及了一个字组件向父组件传递数据的知识需要掌握。\n\n先来绑定点击事件，这时候当然是要在<sunshineItem>组件中绑定了，代码如下：\n\n```\nimport React, { Component } from 'react'; //imrc\nclass sunshineItem  extends Component { //cc\n\n    render() { \n        return ( \n            <div onClick={this.handleClick}>{this.props.content}</div>\n         );\n    }\n\n    handleClick(){\n        console.log('点击....')\n    }\n\n}\n\nexport default sunshineItem;\n```\n\nReact有明确规定，子组件时不能操作父组件里的数据的，所以需要借助一个父组件的方法，来修改父组件的内容。\n\n```\n<ul>\n    {\n        this.state.list.map((item,index)=>{\n            return (\n                <sunshineItem \n                key={index+item}  \n                content={item}\n                index={index}\n                //关键代码-------------------start\n                deleteItem={this.deleteItem.bind(this)}\n                //关键代码-------------------end\n                />\n            )\n        })\n    }\n</ul> \n```\n\n子组件\n\n```\nimport React, { Component } from 'react'; //imrc\nclass sunshineItem  extends Component { //cc\n\t\t//--------------主要代码--------start\n   constructor(props){\n       super(props)\n       this.handleClick=this.handleClick.bind(this)\n   }\n   //--------------主要代码--------end\n    render() { \n        return ( \n            <div onClick={this.handleClick}>{this.props.content}</div>\n         );\n    }\n\n    handleClick(){\n        console.log('点击....',this.props.index)\n        this.props.deleteItem(this.props.index)\n    }\n\n}\n\nexport default sunshineItem;\n```\n\n","source":"_posts/react-11.md","raw":"---\ntitle: React进阶——父子组件的传值\ndate: 2020-05-30 13:05:56\ntags:\ncategories: react\n---\n\n### 父组件向子组件传值\n\n这里只介绍最实用的，最快速的上手方法。就是使用组件属性的形式父组件给子组件传值。比如：我们在`<sunshineItem>组件中加入content`属性，然后给属性传递`{item}`，这样就完成了父组件向子组件传值。\n\n```\n<sunshineItem content={item}/>\n```\n\n现在值已经顺利的传递了过去，这时候可以通过`this.props.xxx`的形式进行接受，比如传递过来的值，可以用如下代码进行接收。\n\n```\nimport React, { Component } from 'react'; //imrc\nclass sunshineItem  extends Component { //cc\n\n    render() { \n        return ( \n            <div>{this.props.content}</div>\n         );\n    }\n}\n\nexport default sunshineItem;\n```\n\n### 子组件向父组件传递数据\n\n现在要作这样一个功能：点击组件中的菜单项后，删除改菜单项。在前边的课程中已经学习了这个知识，知识现在组件拆分了，就涉及了一个字组件向父组件传递数据的知识需要掌握。\n\n先来绑定点击事件，这时候当然是要在<sunshineItem>组件中绑定了，代码如下：\n\n```\nimport React, { Component } from 'react'; //imrc\nclass sunshineItem  extends Component { //cc\n\n    render() { \n        return ( \n            <div onClick={this.handleClick}>{this.props.content}</div>\n         );\n    }\n\n    handleClick(){\n        console.log('点击....')\n    }\n\n}\n\nexport default sunshineItem;\n```\n\nReact有明确规定，子组件时不能操作父组件里的数据的，所以需要借助一个父组件的方法，来修改父组件的内容。\n\n```\n<ul>\n    {\n        this.state.list.map((item,index)=>{\n            return (\n                <sunshineItem \n                key={index+item}  \n                content={item}\n                index={index}\n                //关键代码-------------------start\n                deleteItem={this.deleteItem.bind(this)}\n                //关键代码-------------------end\n                />\n            )\n        })\n    }\n</ul> \n```\n\n子组件\n\n```\nimport React, { Component } from 'react'; //imrc\nclass sunshineItem  extends Component { //cc\n\t\t//--------------主要代码--------start\n   constructor(props){\n       super(props)\n       this.handleClick=this.handleClick.bind(this)\n   }\n   //--------------主要代码--------end\n    render() { \n        return ( \n            <div onClick={this.handleClick}>{this.props.content}</div>\n         );\n    }\n\n    handleClick(){\n        console.log('点击....',this.props.index)\n        this.props.deleteItem(this.props.index)\n    }\n\n}\n\nexport default sunshineItem;\n```\n\n","slug":"react-11","published":1,"updated":"2020-05-30T05:31:14.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6au000lxy0icw7d87us","content":"<h3 id=\"父组件向子组件传值\"><a href=\"#父组件向子组件传值\" class=\"headerlink\" title=\"父组件向子组件传值\"></a>父组件向子组件传值</h3><p>这里只介绍最实用的，最快速的上手方法。就是使用组件属性的形式父组件给子组件传值。比如：我们在<code>&lt;sunshineItem&gt;组件中加入content</code>属性，然后给属性传递<code>{item}</code>，这样就完成了父组件向子组件传值。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">sunshineItem</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在值已经顺利的传递了过去，这时候可以通过<code>this.props.xxx</code>的形式进行接受，比如传递过来的值，可以用如下代码进行接收。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">React</span>, &#123; <span class=\"type\">Component</span> &#125; from <span class=\"symbol\">'reac</span>t'; <span class=\"comment\">//imrc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">sunshineItem</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123; <span class=\"comment\">//cc</span></span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ( </span><br><span class=\"line\">            &lt;div&gt;&#123;<span class=\"keyword\">this</span>.props.content&#125;&lt;/div&gt;</span><br><span class=\"line\">         );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> sunshineItem;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子组件向父组件传递数据\"><a href=\"#子组件向父组件传递数据\" class=\"headerlink\" title=\"子组件向父组件传递数据\"></a>子组件向父组件传递数据</h3><p>现在要作这样一个功能：点击组件中的菜单项后，删除改菜单项。在前边的课程中已经学习了这个知识，知识现在组件拆分了，就涉及了一个字组件向父组件传递数据的知识需要掌握。</p>\n<p>先来绑定点击事件，这时候当然是要在<sunshineItem>组件中绑定了，代码如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">React</span>, &#123; <span class=\"type\">Component</span> &#125; from <span class=\"symbol\">'reac</span>t'; <span class=\"comment\">//imrc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">sunshineItem</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123; <span class=\"comment\">//cc</span></span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ( </span><br><span class=\"line\">            &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;&#123;<span class=\"keyword\">this</span>.props.content&#125;&lt;/div&gt;</span><br><span class=\"line\">         );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick()&#123;</span><br><span class=\"line\">        console.log('点击....')</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> sunshineItem;</span><br></pre></td></tr></table></figure>\n\n<p>React有明确规定，子组件时不能操作父组件里的数据的，所以需要借助一个父组件的方法，来修改父组件的内容。</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state.list.map((item,<span class=\"keyword\">index</span>)=&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;sunshineItem </span><br><span class=\"line\">                key=&#123;<span class=\"keyword\">index</span>+item&#125;  </span><br><span class=\"line\">                content=&#123;item&#125;</span><br><span class=\"line\">                <span class=\"keyword\">index</span>=&#123;<span class=\"keyword\">index</span>&#125;</span><br><span class=\"line\">                <span class=\"comment\">//关键代码-------------------start</span></span><br><span class=\"line\">                deleteItem=&#123;<span class=\"keyword\">this</span>.deleteItem.bind(<span class=\"keyword\">this</span>)&#125;</span><br><span class=\"line\">                <span class=\"comment\">//关键代码-------------------end</span></span><br><span class=\"line\">                /&gt;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<p>子组件</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; from <span class=\"string\">'react'</span>; <span class=\"comment\">//imrc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">sunshineItem</span>  <span class=\"title\">extends</span> <span class=\"title\">Component</span> </span>&#123; <span class=\"comment\">//cc</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//--------------主要代码--------start</span></span><br><span class=\"line\">   <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.handleClick=<span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//--------------主要代码--------end</span></span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ( </span><br><span class=\"line\">            &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;&#123;<span class=\"keyword\">this</span>.props.content&#125;&lt;/div&gt;</span><br><span class=\"line\">         );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick()&#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'点击....'</span>,<span class=\"keyword\">this</span>.props.index)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.deleteItem(<span class=\"keyword\">this</span>.props.index)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> sunshineItem;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"父组件向子组件传值\"><a href=\"#父组件向子组件传值\" class=\"headerlink\" title=\"父组件向子组件传值\"></a>父组件向子组件传值</h3><p>这里只介绍最实用的，最快速的上手方法。就是使用组件属性的形式父组件给子组件传值。比如：我们在<code>&lt;sunshineItem&gt;组件中加入content</code>属性，然后给属性传递<code>{item}</code>，这样就完成了父组件向子组件传值。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">sunshineItem</span> <span class=\"attr\">content</span>=<span class=\"string\">&#123;item&#125;/</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>现在值已经顺利的传递了过去，这时候可以通过<code>this.props.xxx</code>的形式进行接受，比如传递过来的值，可以用如下代码进行接收。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">React</span>, &#123; <span class=\"type\">Component</span> &#125; from <span class=\"symbol\">'reac</span>t'; <span class=\"comment\">//imrc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">sunshineItem</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123; <span class=\"comment\">//cc</span></span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ( </span><br><span class=\"line\">            &lt;div&gt;&#123;<span class=\"keyword\">this</span>.props.content&#125;&lt;/div&gt;</span><br><span class=\"line\">         );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> sunshineItem;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"子组件向父组件传递数据\"><a href=\"#子组件向父组件传递数据\" class=\"headerlink\" title=\"子组件向父组件传递数据\"></a>子组件向父组件传递数据</h3><p>现在要作这样一个功能：点击组件中的菜单项后，删除改菜单项。在前边的课程中已经学习了这个知识，知识现在组件拆分了，就涉及了一个字组件向父组件传递数据的知识需要掌握。</p>\n<p>先来绑定点击事件，这时候当然是要在<sunshineItem>组件中绑定了，代码如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">React</span>, &#123; <span class=\"type\">Component</span> &#125; from <span class=\"symbol\">'reac</span>t'; <span class=\"comment\">//imrc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">sunshineItem</span>  <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123; <span class=\"comment\">//cc</span></span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ( </span><br><span class=\"line\">            &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;&#123;<span class=\"keyword\">this</span>.props.content&#125;&lt;/div&gt;</span><br><span class=\"line\">         );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick()&#123;</span><br><span class=\"line\">        console.log('点击....')</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> sunshineItem;</span><br></pre></td></tr></table></figure>\n\n<p>React有明确规定，子组件时不能操作父组件里的数据的，所以需要借助一个父组件的方法，来修改父组件的内容。</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state.list.map((item,<span class=\"keyword\">index</span>)=&gt;&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;sunshineItem </span><br><span class=\"line\">                key=&#123;<span class=\"keyword\">index</span>+item&#125;  </span><br><span class=\"line\">                content=&#123;item&#125;</span><br><span class=\"line\">                <span class=\"keyword\">index</span>=&#123;<span class=\"keyword\">index</span>&#125;</span><br><span class=\"line\">                <span class=\"comment\">//关键代码-------------------start</span></span><br><span class=\"line\">                deleteItem=&#123;<span class=\"keyword\">this</span>.deleteItem.bind(<span class=\"keyword\">this</span>)&#125;</span><br><span class=\"line\">                <span class=\"comment\">//关键代码-------------------end</span></span><br><span class=\"line\">                /&gt;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<p>子组件</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; from <span class=\"string\">'react'</span>; <span class=\"comment\">//imrc</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">sunshineItem</span>  <span class=\"title\">extends</span> <span class=\"title\">Component</span> </span>&#123; <span class=\"comment\">//cc</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//--------------主要代码--------start</span></span><br><span class=\"line\">   <span class=\"keyword\">constructor</span>(props)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.handleClick=<span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//--------------主要代码--------end</span></span><br><span class=\"line\">    render() &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ( </span><br><span class=\"line\">            &lt;div onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;&gt;&#123;<span class=\"keyword\">this</span>.props.content&#125;&lt;/div&gt;</span><br><span class=\"line\">         );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleClick()&#123;</span><br><span class=\"line\">        console.log(<span class=\"string\">'点击....'</span>,<span class=\"keyword\">this</span>.props.index)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.props.deleteItem(<span class=\"keyword\">this</span>.props.index)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export <span class=\"keyword\">default</span> sunshineItem;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"React高级——生命周期","date":"2020-06-01T09:02:45.000Z","_content":"\nReact声明周期的四个大阶段：\n\n1. `Initialization`:初始化阶段。\n2. `Mounting`: 挂在阶段。\n3. `Updation`: 更新阶段。\n4. `Unmounting`: 销毁阶段\n\n因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。\nReact的生命周期图:\n\n![WechatIMG108](https://gitee.com/sunshine58/image-oss/raw/master/uPic/2020-06/WechatIMG108.png)\n\n### 挂载卸载过程\n\n#### constructor()\n\nconstructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。\n 注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。\n\n#### componentWillMount()\n\ncomponentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。\n\n#### componentDidMount()\n\n组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染\n\n#### componentWillUnmount ()\n\n在此处完成组件的卸载和数据的销毁。\n\n1. clear你在组建中所有的setTimeout,setInterval\n2. 移除所有组建中的监听 removeEventListener\n3. 有时候我们会碰到这个warning:\n\n```csharp\nCan only update a mounted or mounting component. This usually      means you called setState() on an unmounted component. This is a   no-op. Please check the code for the undefined component.\n```\n\n原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning\n 解决方法：\n\n```kotlin\ncomponentDidMount() {\n    this.isMount === true\n    axios.post().then((res) => {\n    this.isMount && this.setState({   // 增加条件ismount为true时\n      aaa:res\n    })\n})\n}\ncomponentWillUnmount() {\n    this.isMount === false\n}\n```\n\n### 更新过程\n\n#### componentWillReceiveProps (nextProps)\n\n1. 在接受父组件改变后的props需要重新渲染组件时用到的比较多\n2. 接受一个参数nextProps\n3. 通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件\n\n\n\n```kotlin\n  componentWillReceiveProps (nextProps) {\n    nextProps.openNotice !== this.props.openNotice&&this.setState({\n        openNotice:nextProps.openNotice\n    }，() => {\n      console.log(this.state.openNotice:nextProps)\n      //将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state\n  })\n}\n```\n\n#### shouldComponentUpdate(nextProps,nextState)\n\n1. 主要用于性能优化(部分更新)\n2. 唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新\n3. 因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断\n\n#### componentWillUpdate (nextProps,nextState)\n\nshouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。\n\n#### componentDidUpdate(prevProps,prevState)\n\n组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。\n\n#### render()\n\nrender函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。\n\n![image-20200601173445152](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200601173445152.png)\n\n####  getDerivedStateFromProps(nextProps, prevState)\n\n代替componentWillReceiveProps()。\n 老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。\n 举个例子:\n\n```kotlin\n// before\ncomponentWillReceiveProps(nextProps) {\n  if (nextProps.isLogin !== this.props.isLogin) {\n    this.setState({ \n      isLogin: nextProps.isLogin,   \n    });\n  }\n  if (nextProps.isLogin) {\n    this.handleClose();\n  }\n}\n\n// after\nstatic getDerivedStateFromProps(nextProps, prevState) {\n  if (nextProps.isLogin !== prevState.isLogin) {\n    return {\n      isLogin: nextProps.isLogin,\n    };\n  }\n  return null;\n}\n\ncomponentDidUpdate(prevProps, prevState) {\n  if (!prevState.isLogin && this.props.isLogin) {\n    this.handleClose();\n  }\n}\n```\n\n这两者最大的不同就是:\n 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。\n\n1. 在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。\n2. 而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。\n\n#### getSnapshotBeforeUpdate(prevProps, prevState)\n\n代替componentWillUpdate。\n 常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。\n 这两者的区别在于：\n\n1. 在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在\n    componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。\n2. getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。\n    此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。","source":"_posts/react-16.md","raw":"---\ntitle: React高级——生命周期\ndate: 2020-06-01 17:02:45\ntags:\ncategories: react\n---\n\nReact声明周期的四个大阶段：\n\n1. `Initialization`:初始化阶段。\n2. `Mounting`: 挂在阶段。\n3. `Updation`: 更新阶段。\n4. `Unmounting`: 销毁阶段\n\n因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。\nReact的生命周期图:\n\n![WechatIMG108](https://gitee.com/sunshine58/image-oss/raw/master/uPic/2020-06/WechatIMG108.png)\n\n### 挂载卸载过程\n\n#### constructor()\n\nconstructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。\n 注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。\n\n#### componentWillMount()\n\ncomponentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。\n\n#### componentDidMount()\n\n组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染\n\n#### componentWillUnmount ()\n\n在此处完成组件的卸载和数据的销毁。\n\n1. clear你在组建中所有的setTimeout,setInterval\n2. 移除所有组建中的监听 removeEventListener\n3. 有时候我们会碰到这个warning:\n\n```csharp\nCan only update a mounted or mounting component. This usually      means you called setState() on an unmounted component. This is a   no-op. Please check the code for the undefined component.\n```\n\n原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning\n 解决方法：\n\n```kotlin\ncomponentDidMount() {\n    this.isMount === true\n    axios.post().then((res) => {\n    this.isMount && this.setState({   // 增加条件ismount为true时\n      aaa:res\n    })\n})\n}\ncomponentWillUnmount() {\n    this.isMount === false\n}\n```\n\n### 更新过程\n\n#### componentWillReceiveProps (nextProps)\n\n1. 在接受父组件改变后的props需要重新渲染组件时用到的比较多\n2. 接受一个参数nextProps\n3. 通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件\n\n\n\n```kotlin\n  componentWillReceiveProps (nextProps) {\n    nextProps.openNotice !== this.props.openNotice&&this.setState({\n        openNotice:nextProps.openNotice\n    }，() => {\n      console.log(this.state.openNotice:nextProps)\n      //将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state\n  })\n}\n```\n\n#### shouldComponentUpdate(nextProps,nextState)\n\n1. 主要用于性能优化(部分更新)\n2. 唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新\n3. 因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断\n\n#### componentWillUpdate (nextProps,nextState)\n\nshouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。\n\n#### componentDidUpdate(prevProps,prevState)\n\n组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。\n\n#### render()\n\nrender函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。\n\n![image-20200601173445152](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200601173445152.png)\n\n####  getDerivedStateFromProps(nextProps, prevState)\n\n代替componentWillReceiveProps()。\n 老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。\n 举个例子:\n\n```kotlin\n// before\ncomponentWillReceiveProps(nextProps) {\n  if (nextProps.isLogin !== this.props.isLogin) {\n    this.setState({ \n      isLogin: nextProps.isLogin,   \n    });\n  }\n  if (nextProps.isLogin) {\n    this.handleClose();\n  }\n}\n\n// after\nstatic getDerivedStateFromProps(nextProps, prevState) {\n  if (nextProps.isLogin !== prevState.isLogin) {\n    return {\n      isLogin: nextProps.isLogin,\n    };\n  }\n  return null;\n}\n\ncomponentDidUpdate(prevProps, prevState) {\n  if (!prevState.isLogin && this.props.isLogin) {\n    this.handleClose();\n  }\n}\n```\n\n这两者最大的不同就是:\n 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。\n\n1. 在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。\n2. 而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。\n\n#### getSnapshotBeforeUpdate(prevProps, prevState)\n\n代替componentWillUpdate。\n 常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。\n 这两者的区别在于：\n\n1. 在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在\n    componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。\n2. getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。\n    此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。","slug":"react-16","published":1,"updated":"2020-06-01T09:40:18.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6av000nxy0i8u2hern6","content":"<p>React声明周期的四个大阶段：</p>\n<ol>\n<li><code>Initialization</code>:初始化阶段。</li>\n<li><code>Mounting</code>: 挂在阶段。</li>\n<li><code>Updation</code>: 更新阶段。</li>\n<li><code>Unmounting</code>: 销毁阶段</li>\n</ol>\n<p>因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。<br>React的生命周期图:</p>\n<p><img src=\"https://gitee.com/sunshine58/image-oss/raw/master/uPic/2020-06/WechatIMG108.png\" alt=\"WechatIMG108\"></p>\n<h3 id=\"挂载卸载过程\"><a href=\"#挂载卸载过程\" class=\"headerlink\" title=\"挂载卸载过程\"></a>挂载卸载过程</h3><h4 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor()\"></a>constructor()</h4><p>constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。<br> 注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。</p>\n<h4 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount()\"></a>componentWillMount()</h4><p>componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。</p>\n<h4 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount()\"></a>componentDidMount()</h4><p>组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染</p>\n<h4 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount ()\"></a>componentWillUnmount ()</h4><p>在此处完成组件的卸载和数据的销毁。</p>\n<ol>\n<li>clear你在组建中所有的setTimeout,setInterval</li>\n<li>移除所有组建中的监听 removeEventListener</li>\n<li>有时候我们会碰到这个warning:</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Can only update a mounted or mounting component. <span class=\"function\">This usually      means you called <span class=\"title\">setState</span>(<span class=\"params\"></span>) <span class=\"keyword\">on</span> an unmounted component. This <span class=\"keyword\">is</span> a   no-op. Please check the code <span class=\"keyword\">for</span> the undefined component.</span></span><br></pre></td></tr></table></figure>\n\n<p>原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning<br> 解决方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isMount === <span class=\"literal\">true</span></span><br><span class=\"line\">    axios.post().then((res) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isMount &amp;&amp; <span class=\"keyword\">this</span>.setState(&#123;   <span class=\"comment\">// 增加条件ismount为true时</span></span><br><span class=\"line\">      aaa:res</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isMount === <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新过程\"><a href=\"#更新过程\" class=\"headerlink\" title=\"更新过程\"></a>更新过程</h3><h4 id=\"componentWillReceiveProps-nextProps\"><a href=\"#componentWillReceiveProps-nextProps\" class=\"headerlink\" title=\"componentWillReceiveProps (nextProps)\"></a>componentWillReceiveProps (nextProps)</h4><ol>\n<li>在接受父组件改变后的props需要重新渲染组件时用到的比较多</li>\n<li>接受一个参数nextProps</li>\n<li>通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  componentWillReceiveProps (nextProps) &#123;</span><br><span class=\"line\">    nextProps.openNotice !== <span class=\"keyword\">this</span>.props.openNotice&amp;&amp;<span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        openNotice:nextProps.openNotice</span><br><span class=\"line\">    &#125;，() =&gt; &#123;</span><br><span class=\"line\">      console.log(<span class=\"keyword\">this</span>.state.openNotice:nextProps)</span><br><span class=\"line\">      <span class=\"comment\">//将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"shouldComponentUpdate-nextProps-nextState\"><a href=\"#shouldComponentUpdate-nextProps-nextState\" class=\"headerlink\" title=\"shouldComponentUpdate(nextProps,nextState)\"></a>shouldComponentUpdate(nextProps,nextState)</h4><ol>\n<li>主要用于性能优化(部分更新)</li>\n<li>唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新</li>\n<li>因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</li>\n</ol>\n<h4 id=\"componentWillUpdate-nextProps-nextState\"><a href=\"#componentWillUpdate-nextProps-nextState\" class=\"headerlink\" title=\"componentWillUpdate (nextProps,nextState)\"></a>componentWillUpdate (nextProps,nextState)</h4><p>shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。</p>\n<h4 id=\"componentDidUpdate-prevProps-prevState\"><a href=\"#componentDidUpdate-prevProps-prevState\" class=\"headerlink\" title=\"componentDidUpdate(prevProps,prevState)\"></a>componentDidUpdate(prevProps,prevState)</h4><p>组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。</p>\n<h4 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h4><p>render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。</p>\n<p>![image-20200601173445152](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200601173445152.png)</p>\n<h4 id=\"getDerivedStateFromProps-nextProps-prevState\"><a href=\"#getDerivedStateFromProps-nextProps-prevState\" class=\"headerlink\" title=\"getDerivedStateFromProps(nextProps, prevState)\"></a>getDerivedStateFromProps(nextProps, prevState)</h4><p>代替componentWillReceiveProps()。<br> 老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。<br> 举个例子:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextProps.isLogin !== <span class=\"keyword\">this</span>.props.isLogin) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; </span><br><span class=\"line\">      isLogin: nextProps.isLogin,   </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextProps.isLogin) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClose();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\">static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextProps.isLogin !== prevState.isLogin) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      isLogin: nextProps.isLogin,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!prevState.isLogin &amp;&amp; <span class=\"keyword\">this</span>.props.isLogin) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClose();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两者最大的不同就是:<br> 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。</p>\n<ol>\n<li>在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。</li>\n<li>而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。</li>\n</ol>\n<h4 id=\"getSnapshotBeforeUpdate-prevProps-prevState\"><a href=\"#getSnapshotBeforeUpdate-prevProps-prevState\" class=\"headerlink\" title=\"getSnapshotBeforeUpdate(prevProps, prevState)\"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h4><p>代替componentWillUpdate。<br> 常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。<br> 这两者的区别在于：</p>\n<ol>\n<li>在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在<br> componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。</li>\n<li>getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。<br> 此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>React声明周期的四个大阶段：</p>\n<ol>\n<li><code>Initialization</code>:初始化阶段。</li>\n<li><code>Mounting</code>: 挂在阶段。</li>\n<li><code>Updation</code>: 更新阶段。</li>\n<li><code>Unmounting</code>: 销毁阶段</li>\n</ol>\n<p>因此可以把React的生命周期分为两类：挂载卸载过程和更新过程。<br>React的生命周期图:</p>\n<p><img src=\"https://gitee.com/sunshine58/image-oss/raw/master/uPic/2020-06/WechatIMG108.png\" alt=\"WechatIMG108\"></p>\n<h3 id=\"挂载卸载过程\"><a href=\"#挂载卸载过程\" class=\"headerlink\" title=\"挂载卸载过程\"></a>挂载卸载过程</h3><h4 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor()\"></a>constructor()</h4><p>constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。<br> 注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。</p>\n<h4 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount()\"></a>componentWillMount()</h4><p>componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。</p>\n<h4 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount()\"></a>componentDidMount()</h4><p>组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染</p>\n<h4 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount ()\"></a>componentWillUnmount ()</h4><p>在此处完成组件的卸载和数据的销毁。</p>\n<ol>\n<li>clear你在组建中所有的setTimeout,setInterval</li>\n<li>移除所有组建中的监听 removeEventListener</li>\n<li>有时候我们会碰到这个warning:</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Can only update a mounted or mounting component. <span class=\"function\">This usually      means you called <span class=\"title\">setState</span>(<span class=\"params\"></span>) <span class=\"keyword\">on</span> an unmounted component. This <span class=\"keyword\">is</span> a   no-op. Please check the code <span class=\"keyword\">for</span> the undefined component.</span></span><br></pre></td></tr></table></figure>\n\n<p>原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning<br> 解决方法：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isMount === <span class=\"literal\">true</span></span><br><span class=\"line\">    axios.post().then((res) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isMount &amp;&amp; <span class=\"keyword\">this</span>.setState(&#123;   <span class=\"comment\">// 增加条件ismount为true时</span></span><br><span class=\"line\">      aaa:res</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isMount === <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新过程\"><a href=\"#更新过程\" class=\"headerlink\" title=\"更新过程\"></a>更新过程</h3><h4 id=\"componentWillReceiveProps-nextProps\"><a href=\"#componentWillReceiveProps-nextProps\" class=\"headerlink\" title=\"componentWillReceiveProps (nextProps)\"></a>componentWillReceiveProps (nextProps)</h4><ol>\n<li>在接受父组件改变后的props需要重新渲染组件时用到的比较多</li>\n<li>接受一个参数nextProps</li>\n<li>通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  componentWillReceiveProps (nextProps) &#123;</span><br><span class=\"line\">    nextProps.openNotice !== <span class=\"keyword\">this</span>.props.openNotice&amp;&amp;<span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        openNotice:nextProps.openNotice</span><br><span class=\"line\">    &#125;，() =&gt; &#123;</span><br><span class=\"line\">      console.log(<span class=\"keyword\">this</span>.state.openNotice:nextProps)</span><br><span class=\"line\">      <span class=\"comment\">//将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"shouldComponentUpdate-nextProps-nextState\"><a href=\"#shouldComponentUpdate-nextProps-nextState\" class=\"headerlink\" title=\"shouldComponentUpdate(nextProps,nextState)\"></a>shouldComponentUpdate(nextProps,nextState)</h4><ol>\n<li>主要用于性能优化(部分更新)</li>\n<li>唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新</li>\n<li>因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</li>\n</ol>\n<h4 id=\"componentWillUpdate-nextProps-nextState\"><a href=\"#componentWillUpdate-nextProps-nextState\" class=\"headerlink\" title=\"componentWillUpdate (nextProps,nextState)\"></a>componentWillUpdate (nextProps,nextState)</h4><p>shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。</p>\n<h4 id=\"componentDidUpdate-prevProps-prevState\"><a href=\"#componentDidUpdate-prevProps-prevState\" class=\"headerlink\" title=\"componentDidUpdate(prevProps,prevState)\"></a>componentDidUpdate(prevProps,prevState)</h4><p>组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。</p>\n<h4 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h4><p>render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。</p>\n<p>![image-20200601173445152](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200601173445152.png)</p>\n<h4 id=\"getDerivedStateFromProps-nextProps-prevState\"><a href=\"#getDerivedStateFromProps-nextProps-prevState\" class=\"headerlink\" title=\"getDerivedStateFromProps(nextProps, prevState)\"></a>getDerivedStateFromProps(nextProps, prevState)</h4><p>代替componentWillReceiveProps()。<br> 老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。<br> 举个例子:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// before</span></span><br><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextProps.isLogin !== <span class=\"keyword\">this</span>.props.isLogin) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; </span><br><span class=\"line\">      isLogin: nextProps.isLogin,   </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextProps.isLogin) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClose();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after</span></span><br><span class=\"line\">static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextProps.isLogin !== prevState.isLogin) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      isLogin: nextProps.isLogin,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!prevState.isLogin &amp;&amp; <span class=\"keyword\">this</span>.props.isLogin) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClose();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两者最大的不同就是:<br> 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。</p>\n<ol>\n<li>在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。</li>\n<li>而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。</li>\n</ol>\n<h4 id=\"getSnapshotBeforeUpdate-prevProps-prevState\"><a href=\"#getSnapshotBeforeUpdate-prevProps-prevState\" class=\"headerlink\" title=\"getSnapshotBeforeUpdate(prevProps, prevState)\"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h4><p>代替componentWillUpdate。<br> 常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。<br> 这两者的区别在于：</p>\n<ol>\n<li>在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在<br> componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。</li>\n<li>getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。<br> 此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。</li>\n</ol>\n"},{"title":"React高级——生命周期改善程序性能","date":"2020-06-28T07:21:25.000Z","_content":"\n首先你要确认你安装了`React Developer Tools` 有了这个浏览器插件，就可以在控制台中找到React标签，然后在右边点开设置，选中`highlight Updates`。\n\n![image-20200628160640699](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200628160640699.png)\n\n这时候你在浏览器的文本框中输入一下内容，你可以清楚的看到子组件也发生了重新`render`的情况。\n\n有很多程序员会忽略这样的性能损耗，认为没有什么大不了的，但是软件的卡顿是一点点产生的，所以必须要减少性能损耗。\n\n这时我们可以用`shouldComponentUpdate`解决\n\n这个问题看似很小，但是当你页面很复杂时，足以影响用户体验。其实用`shouldComponentUpdate`函数就可以简单的解决调这个问题。\n\n![image-20200628161020272](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200628161020272.png)\n\n现在的代码就优雅一些了，也不那么暴力了。这就算是完美解决了子组件的渲染性能问题，你写的代码质量也得到了提高。","source":"_posts/react-17.md","raw":"---\ntitle: React高级——生命周期改善程序性能\ndate: 2020-06-28 15:21:25\ntags:\ncategories: react\n---\n\n首先你要确认你安装了`React Developer Tools` 有了这个浏览器插件，就可以在控制台中找到React标签，然后在右边点开设置，选中`highlight Updates`。\n\n![image-20200628160640699](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200628160640699.png)\n\n这时候你在浏览器的文本框中输入一下内容，你可以清楚的看到子组件也发生了重新`render`的情况。\n\n有很多程序员会忽略这样的性能损耗，认为没有什么大不了的，但是软件的卡顿是一点点产生的，所以必须要减少性能损耗。\n\n这时我们可以用`shouldComponentUpdate`解决\n\n这个问题看似很小，但是当你页面很复杂时，足以影响用户体验。其实用`shouldComponentUpdate`函数就可以简单的解决调这个问题。\n\n![image-20200628161020272](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200628161020272.png)\n\n现在的代码就优雅一些了，也不那么暴力了。这就算是完美解决了子组件的渲染性能问题，你写的代码质量也得到了提高。","slug":"react-17","published":1,"updated":"2020-06-28T08:10:44.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6aw000pxy0i5m7o7oo0","content":"<p>首先你要确认你安装了<code>React Developer Tools</code> 有了这个浏览器插件，就可以在控制台中找到React标签，然后在右边点开设置，选中<code>highlight Updates</code>。</p>\n<p>![image-20200628160640699](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200628160640699.png)</p>\n<p>这时候你在浏览器的文本框中输入一下内容，你可以清楚的看到子组件也发生了重新<code>render</code>的情况。</p>\n<p>有很多程序员会忽略这样的性能损耗，认为没有什么大不了的，但是软件的卡顿是一点点产生的，所以必须要减少性能损耗。</p>\n<p>这时我们可以用<code>shouldComponentUpdate</code>解决</p>\n<p>这个问题看似很小，但是当你页面很复杂时，足以影响用户体验。其实用<code>shouldComponentUpdate</code>函数就可以简单的解决调这个问题。</p>\n<p>![image-20200628161020272](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200628161020272.png)</p>\n<p>现在的代码就优雅一些了，也不那么暴力了。这就算是完美解决了子组件的渲染性能问题，你写的代码质量也得到了提高。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先你要确认你安装了<code>React Developer Tools</code> 有了这个浏览器插件，就可以在控制台中找到React标签，然后在右边点开设置，选中<code>highlight Updates</code>。</p>\n<p>![image-20200628160640699](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200628160640699.png)</p>\n<p>这时候你在浏览器的文本框中输入一下内容，你可以清楚的看到子组件也发生了重新<code>render</code>的情况。</p>\n<p>有很多程序员会忽略这样的性能损耗，认为没有什么大不了的，但是软件的卡顿是一点点产生的，所以必须要减少性能损耗。</p>\n<p>这时我们可以用<code>shouldComponentUpdate</code>解决</p>\n<p>这个问题看似很小，但是当你页面很复杂时，足以影响用户体验。其实用<code>shouldComponentUpdate</code>函数就可以简单的解决调这个问题。</p>\n<p>![image-20200628161020272](/Users/zhaohui/Library/Application Support/typora-user-images/image-20200628161020272.png)</p>\n<p>现在的代码就优雅一些了，也不那么暴力了。这就算是完美解决了子组件的渲染性能问题，你写的代码质量也得到了提高。</p>\n"},{"title":"React高级——axios数据请求","date":"2020-06-28T07:22:46.000Z","_content":"\n### 安装axios\n\n`Axios`的安装可以使用npm来进行安装，你可以直接在项目根目录下，输入下面的代码。\n\n***npm install -save axios***\n\n安装好`axiso`之后，需要在使用ajax的地方先引入`axios` \n\n```\nimport axios from 'axios'\n```\n\n引入后，可以在`componentDidMount`生命周期函数里请求ajax，我也建议在`componentDidMount`函数里执行，因为在render里执行，会出现很多问题，比如一直循环渲染；在`componentWillMount`里执行，在使用RN时，又会有冲突。所以强烈建议在`componentDidMount`函数里作`ajax`请求。\n\n```\ncomponentDidMount(){\naxios.post('https:...')\n.then((res)=>{console.log('axios 获取数据成功:'+JSON.stringify(res)) })\n.catch((error)=>{console.log('axios 获取数据失败'+error)})\n}\n```\n\n","source":"_posts/react-18.md","raw":"---\ntitle: React高级——axios数据请求\ndate: 2020-06-28 15:22:46\ntags:\ncategories: react\n---\n\n### 安装axios\n\n`Axios`的安装可以使用npm来进行安装，你可以直接在项目根目录下，输入下面的代码。\n\n***npm install -save axios***\n\n安装好`axiso`之后，需要在使用ajax的地方先引入`axios` \n\n```\nimport axios from 'axios'\n```\n\n引入后，可以在`componentDidMount`生命周期函数里请求ajax，我也建议在`componentDidMount`函数里执行，因为在render里执行，会出现很多问题，比如一直循环渲染；在`componentWillMount`里执行，在使用RN时，又会有冲突。所以强烈建议在`componentDidMount`函数里作`ajax`请求。\n\n```\ncomponentDidMount(){\naxios.post('https:...')\n.then((res)=>{console.log('axios 获取数据成功:'+JSON.stringify(res)) })\n.catch((error)=>{console.log('axios 获取数据失败'+error)})\n}\n```\n\n","slug":"react-18","published":1,"updated":"2020-06-28T08:47:49.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6aw000rxy0i6jq1ej0s","content":"<h3 id=\"安装axios\"><a href=\"#安装axios\" class=\"headerlink\" title=\"安装axios\"></a>安装axios</h3><p><code>Axios</code>的安装可以使用npm来进行安装，你可以直接在项目根目录下，输入下面的代码。</p>\n<p><strong><em>npm install -save axios</em></strong></p>\n<p>安装好<code>axiso</code>之后，需要在使用ajax的地方先引入<code>axios</code> </p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span></span><br></pre></td></tr></table></figure>\n\n<p>引入后，可以在<code>componentDidMount</code>生命周期函数里请求ajax，我也建议在<code>componentDidMount</code>函数里执行，因为在render里执行，会出现很多问题，比如一直循环渲染；在<code>componentWillMount</code>里执行，在使用RN时，又会有冲突。所以强烈建议在<code>componentDidMount</code>函数里作<code>ajax</code>请求。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">axios.post(<span class=\"string\">'https:...'</span>)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"params\">(res)</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'axios 获取数据成功:'</span>+JSON.stringify(res)) &#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"params\">(error)</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'axios 获取数据失败'</span>+error)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装axios\"><a href=\"#安装axios\" class=\"headerlink\" title=\"安装axios\"></a>安装axios</h3><p><code>Axios</code>的安装可以使用npm来进行安装，你可以直接在项目根目录下，输入下面的代码。</p>\n<p><strong><em>npm install -save axios</em></strong></p>\n<p>安装好<code>axiso</code>之后，需要在使用ajax的地方先引入<code>axios</code> </p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span></span><br></pre></td></tr></table></figure>\n\n<p>引入后，可以在<code>componentDidMount</code>生命周期函数里请求ajax，我也建议在<code>componentDidMount</code>函数里执行，因为在render里执行，会出现很多问题，比如一直循环渲染；在<code>componentWillMount</code>里执行，在使用RN时，又会有冲突。所以强烈建议在<code>componentDidMount</code>函数里作<code>ajax</code>请求。</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">axios.post(<span class=\"string\">'https:...'</span>)</span><br><span class=\"line\">.<span class=\"keyword\">then</span>(<span class=\"function\"><span class=\"params\">(res)</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'axios 获取数据成功:'</span>+JSON.stringify(res)) &#125;)</span><br><span class=\"line\">.<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"params\">(error)</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'axios 获取数据失败'</span>+error)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"React高级——调试工具的安装及使用","date":"2020-05-30T05:41:39.000Z","_content":"\n我们经常使用`console.log`这种很二的形式来调试程序。其实React在浏览器端是有一个调试工具的，这就是`React developer tools`，这个是React人必下的一个调试工具。这节课就主要学习一下`React developer tools`的下载和简单使用。\n\n### 下载React developer tools\n\n这个需要在`chrome浏览器`里进行，并且需要科学上网（自行百度）。\n\n1. 点击浏览器地址栏最右边的`...`，然后选择`更多工具`,然后选择`扩展程序`。\n2. 点击`打开chrome网上应用店`,直接在搜索框里搜索`React`，出现的第一个就是。\n3. 点击`添加至Chrome`,然后就是等待了..........\n\n这段内容推荐看视频吧，其实并不复杂，但是都是需要上图的，我又懒得作图。\n\n### React developer tools 的三种状态\n\n`React developer tools`有三种颜色，三种颜色代表三种状态：\n\n1. 灰色： 这种就是不可以使用，说明页面不是又React编写的。\n2. 黑色: 说明页面是用React编写的，并且处于生成环境当中。\n3. 红色： 说明页面是用React编写的，并且处于调试环境当中。\n\n### React developer tools 的使用\n\n打开浏览器，然后按`F12`,打开开发者工具，然后在面板的最后一个，你会返现一个`React`,这个就是安装的插件了。\n\n在这里你可以清晰的看到React的结构，让自己写的代码更加清晰，你还可以看到组间距的数据传递，再也不用写`console.log`来测试程序了。\n\n**总结** : 这节课我们学习了React调试工具的安装和使用，在工作中一个前端的调试都是在这里进行的","source":"_posts/react-13.md","raw":"---\ntitle: React高级——调试工具的安装及使用\ndate: 2020-05-30 13:41:39\ntags:\ncategories: react\n---\n\n我们经常使用`console.log`这种很二的形式来调试程序。其实React在浏览器端是有一个调试工具的，这就是`React developer tools`，这个是React人必下的一个调试工具。这节课就主要学习一下`React developer tools`的下载和简单使用。\n\n### 下载React developer tools\n\n这个需要在`chrome浏览器`里进行，并且需要科学上网（自行百度）。\n\n1. 点击浏览器地址栏最右边的`...`，然后选择`更多工具`,然后选择`扩展程序`。\n2. 点击`打开chrome网上应用店`,直接在搜索框里搜索`React`，出现的第一个就是。\n3. 点击`添加至Chrome`,然后就是等待了..........\n\n这段内容推荐看视频吧，其实并不复杂，但是都是需要上图的，我又懒得作图。\n\n### React developer tools 的三种状态\n\n`React developer tools`有三种颜色，三种颜色代表三种状态：\n\n1. 灰色： 这种就是不可以使用，说明页面不是又React编写的。\n2. 黑色: 说明页面是用React编写的，并且处于生成环境当中。\n3. 红色： 说明页面是用React编写的，并且处于调试环境当中。\n\n### React developer tools 的使用\n\n打开浏览器，然后按`F12`,打开开发者工具，然后在面板的最后一个，你会返现一个`React`,这个就是安装的插件了。\n\n在这里你可以清晰的看到React的结构，让自己写的代码更加清晰，你还可以看到组间距的数据传递，再也不用写`console.log`来测试程序了。\n\n**总结** : 这节课我们学习了React调试工具的安装和使用，在工作中一个前端的调试都是在这里进行的","slug":"react-13","published":1,"updated":"2020-05-30T05:49:28.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6ax000txy0icde5h2kh","content":"<p>我们经常使用<code>console.log</code>这种很二的形式来调试程序。其实React在浏览器端是有一个调试工具的，这就是<code>React developer tools</code>，这个是React人必下的一个调试工具。这节课就主要学习一下<code>React developer tools</code>的下载和简单使用。</p>\n<h3 id=\"下载React-developer-tools\"><a href=\"#下载React-developer-tools\" class=\"headerlink\" title=\"下载React developer tools\"></a>下载React developer tools</h3><p>这个需要在<code>chrome浏览器</code>里进行，并且需要科学上网（自行百度）。</p>\n<ol>\n<li>点击浏览器地址栏最右边的<code>...</code>，然后选择<code>更多工具</code>,然后选择<code>扩展程序</code>。</li>\n<li>点击<code>打开chrome网上应用店</code>,直接在搜索框里搜索<code>React</code>，出现的第一个就是。</li>\n<li>点击<code>添加至Chrome</code>,然后就是等待了……….</li>\n</ol>\n<p>这段内容推荐看视频吧，其实并不复杂，但是都是需要上图的，我又懒得作图。</p>\n<h3 id=\"React-developer-tools-的三种状态\"><a href=\"#React-developer-tools-的三种状态\" class=\"headerlink\" title=\"React developer tools 的三种状态\"></a>React developer tools 的三种状态</h3><p><code>React developer tools</code>有三种颜色，三种颜色代表三种状态：</p>\n<ol>\n<li>灰色： 这种就是不可以使用，说明页面不是又React编写的。</li>\n<li>黑色: 说明页面是用React编写的，并且处于生成环境当中。</li>\n<li>红色： 说明页面是用React编写的，并且处于调试环境当中。</li>\n</ol>\n<h3 id=\"React-developer-tools-的使用\"><a href=\"#React-developer-tools-的使用\" class=\"headerlink\" title=\"React developer tools 的使用\"></a>React developer tools 的使用</h3><p>打开浏览器，然后按<code>F12</code>,打开开发者工具，然后在面板的最后一个，你会返现一个<code>React</code>,这个就是安装的插件了。</p>\n<p>在这里你可以清晰的看到React的结构，让自己写的代码更加清晰，你还可以看到组间距的数据传递，再也不用写<code>console.log</code>来测试程序了。</p>\n<p><strong>总结</strong> : 这节课我们学习了React调试工具的安装和使用，在工作中一个前端的调试都是在这里进行的</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们经常使用<code>console.log</code>这种很二的形式来调试程序。其实React在浏览器端是有一个调试工具的，这就是<code>React developer tools</code>，这个是React人必下的一个调试工具。这节课就主要学习一下<code>React developer tools</code>的下载和简单使用。</p>\n<h3 id=\"下载React-developer-tools\"><a href=\"#下载React-developer-tools\" class=\"headerlink\" title=\"下载React developer tools\"></a>下载React developer tools</h3><p>这个需要在<code>chrome浏览器</code>里进行，并且需要科学上网（自行百度）。</p>\n<ol>\n<li>点击浏览器地址栏最右边的<code>...</code>，然后选择<code>更多工具</code>,然后选择<code>扩展程序</code>。</li>\n<li>点击<code>打开chrome网上应用店</code>,直接在搜索框里搜索<code>React</code>，出现的第一个就是。</li>\n<li>点击<code>添加至Chrome</code>,然后就是等待了……….</li>\n</ol>\n<p>这段内容推荐看视频吧，其实并不复杂，但是都是需要上图的，我又懒得作图。</p>\n<h3 id=\"React-developer-tools-的三种状态\"><a href=\"#React-developer-tools-的三种状态\" class=\"headerlink\" title=\"React developer tools 的三种状态\"></a>React developer tools 的三种状态</h3><p><code>React developer tools</code>有三种颜色，三种颜色代表三种状态：</p>\n<ol>\n<li>灰色： 这种就是不可以使用，说明页面不是又React编写的。</li>\n<li>黑色: 说明页面是用React编写的，并且处于生成环境当中。</li>\n<li>红色： 说明页面是用React编写的，并且处于调试环境当中。</li>\n</ol>\n<h3 id=\"React-developer-tools-的使用\"><a href=\"#React-developer-tools-的使用\" class=\"headerlink\" title=\"React developer tools 的使用\"></a>React developer tools 的使用</h3><p>打开浏览器，然后按<code>F12</code>,打开开发者工具，然后在面板的最后一个，你会返现一个<code>React</code>,这个就是安装的插件了。</p>\n<p>在这里你可以清晰的看到React的结构，让自己写的代码更加清晰，你还可以看到组间距的数据传递，再也不用写<code>console.log</code>来测试程序了。</p>\n<p><strong>总结</strong> : 这节课我们学习了React调试工具的安装和使用，在工作中一个前端的调试都是在这里进行的</p>\n"},{"title":"React高级——PropTypes校验传递值","date":"2020-05-30T05:49:16.000Z","_content":"\n### React中的类型检查：prop-types 包\n\n```\nimport PropTypes from 'prop-types';\n```\n\n编写组件\n\n```\nimport PropTypes from 'prop-types';\n\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: PropTypes.string\n};\n```\n\n`PropTypes` 提供一系列验证器，可用于确保组件接收到的数据类型是有效的。在本例中, 我们使用了 `PropTypes.string`。当传入的 `prop` 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，`propTypes` 仅在开发模式下进行检查。\n\npropTypes提供了使用不同验证器的例子\n\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // 你可以将属性声明为 JS 原生类型，默认情况下\n  // 这些属性都是可选的。\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // 任何可被渲染的元素（包括数字、字符串、元素或数组）\n  // (或 Fragment) 也包含这些类型。\n  optionalNode: PropTypes.node,\n\n  // 一个 React 元素。\n  optionalElement: PropTypes.element,\n\n  // 一个 React 元素类型（即，MyComponent）。\n  optionalElementType: PropTypes.elementType,\n\n  // 你也可以声明 prop 为类的实例，这里使用\n  // JS 的 instanceof 操作符。\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // 你可以让你的 prop 只能是特定的值，指定它为\n  // 枚举类型。\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // 一个对象可以是几种类型中的任意一个类型\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // 可以指定一个数组由某一类型的元素组成\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // 可以指定一个对象由某一类型的值组成\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // 可以指定一个对象由特定的类型值组成\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n  \n  // An object with warnings on extra properties\n  optionalObjectWithStrictShape: PropTypes.exact({\n    name: PropTypes.string,\n    quantity: PropTypes.number\n  }),   \n\n  // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保\n  // 这个 prop 没有被提供时，会打印警告信息。\n  requiredFunc: PropTypes.func.isRequired,\n\n  // 任意类型的数据\n  requiredAny: PropTypes.any.isRequired,\n\n  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。\n  // 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。\n  // 它应该在验证失败时返回一个 Error 对象。\n  // 验证器将验证数组或对象中的每个值。验证器的前两个参数\n  // 第一个是数组或对象本身\n  // 第二个是他们当前的键。\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n\n```\n\n限制单个元素\n\n可以通过PropsTypes.element来确保传递组件的children中只包含一个元素。\n\n```\nimport PropTypes from 'prop-types';\n\nclass MyComponent extends React.Component {\n  render() {\n    // 这必须只有一个元素，否则控制台会打印警告。\n    const children = this.props.children;\n    return (\n      <div>\n        {children}\n      </div>\n    );\n  }\n}\n\nMyComponent.propTypes = {\n  children: PropTypes.element.isRequired\n};\n```\n\n### 默认prop值\n\n您可以通过配置特定的 `defaultProps` 属性来定义 `props` 的默认值：\n\n```\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\n// 指定 props 的默认值：\nGreeting.defaultProps = {\n  name: 'Stranger'\n};\n\n// 渲染出 \"Hello, Stranger\"：\nReactDOM.render(\n  <Greeting />,\n  document.getElementById('example')\n);\n```\n\n如果你正在使用像 [transform-class-properties](https://babeljs.io/docs/plugins/transform-class-properties/) 的 Babel 转换工具，你也可以在 React 组件类中声明 `defaultProps` 作为静态属性。此语法提案还没有最终确定，需要进行编译后才能在浏览器中运行。要了解更多信息，请查阅 [class fields proposal](https://github.com/tc39/proposal-class-fields)。\n\n```\nclass Greeting extends React.Component {\n  static defaultProps = {\n    name: 'stranger'\n  }\n\n  render() {\n    return (\n      <div>Hello, {this.props.name}</div>\n    )\n  }\n}\n```\n\n`defaultProps` 用于确保 `this.props.name` 在父组件没有\b指定其值时，有一个默认值。`propTypes` 类型检查发生在 `defaultProps` 赋值后，所以类型检查也适用于 `defaultProps`。","source":"_posts/react-14.md","raw":"---\ntitle: React高级——PropTypes校验传递值\ndate: 2020-05-30 13:49:16\ntags:\ncategories: react\n---\n\n### React中的类型检查：prop-types 包\n\n```\nimport PropTypes from 'prop-types';\n```\n\n编写组件\n\n```\nimport PropTypes from 'prop-types';\n\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: PropTypes.string\n};\n```\n\n`PropTypes` 提供一系列验证器，可用于确保组件接收到的数据类型是有效的。在本例中, 我们使用了 `PropTypes.string`。当传入的 `prop` 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，`propTypes` 仅在开发模式下进行检查。\n\npropTypes提供了使用不同验证器的例子\n\n```\nimport PropTypes from 'prop-types';\n\nMyComponent.propTypes = {\n  // 你可以将属性声明为 JS 原生类型，默认情况下\n  // 这些属性都是可选的。\n  optionalArray: PropTypes.array,\n  optionalBool: PropTypes.bool,\n  optionalFunc: PropTypes.func,\n  optionalNumber: PropTypes.number,\n  optionalObject: PropTypes.object,\n  optionalString: PropTypes.string,\n  optionalSymbol: PropTypes.symbol,\n\n  // 任何可被渲染的元素（包括数字、字符串、元素或数组）\n  // (或 Fragment) 也包含这些类型。\n  optionalNode: PropTypes.node,\n\n  // 一个 React 元素。\n  optionalElement: PropTypes.element,\n\n  // 一个 React 元素类型（即，MyComponent）。\n  optionalElementType: PropTypes.elementType,\n\n  // 你也可以声明 prop 为类的实例，这里使用\n  // JS 的 instanceof 操作符。\n  optionalMessage: PropTypes.instanceOf(Message),\n\n  // 你可以让你的 prop 只能是特定的值，指定它为\n  // 枚举类型。\n  optionalEnum: PropTypes.oneOf(['News', 'Photos']),\n\n  // 一个对象可以是几种类型中的任意一个类型\n  optionalUnion: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.instanceOf(Message)\n  ]),\n\n  // 可以指定一个数组由某一类型的元素组成\n  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),\n\n  // 可以指定一个对象由某一类型的值组成\n  optionalObjectOf: PropTypes.objectOf(PropTypes.number),\n\n  // 可以指定一个对象由特定的类型值组成\n  optionalObjectWithShape: PropTypes.shape({\n    color: PropTypes.string,\n    fontSize: PropTypes.number\n  }),\n  \n  // An object with warnings on extra properties\n  optionalObjectWithStrictShape: PropTypes.exact({\n    name: PropTypes.string,\n    quantity: PropTypes.number\n  }),   \n\n  // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保\n  // 这个 prop 没有被提供时，会打印警告信息。\n  requiredFunc: PropTypes.func.isRequired,\n\n  // 任意类型的数据\n  requiredAny: PropTypes.any.isRequired,\n\n  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。\n  // 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。\n  customProp: function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  },\n\n  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。\n  // 它应该在验证失败时返回一个 Error 对象。\n  // 验证器将验证数组或对象中的每个值。验证器的前两个参数\n  // 第一个是数组或对象本身\n  // 第二个是他们当前的键。\n  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n      return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n      );\n    }\n  })\n};\n\n```\n\n限制单个元素\n\n可以通过PropsTypes.element来确保传递组件的children中只包含一个元素。\n\n```\nimport PropTypes from 'prop-types';\n\nclass MyComponent extends React.Component {\n  render() {\n    // 这必须只有一个元素，否则控制台会打印警告。\n    const children = this.props.children;\n    return (\n      <div>\n        {children}\n      </div>\n    );\n  }\n}\n\nMyComponent.propTypes = {\n  children: PropTypes.element.isRequired\n};\n```\n\n### 默认prop值\n\n您可以通过配置特定的 `defaultProps` 属性来定义 `props` 的默认值：\n\n```\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\n// 指定 props 的默认值：\nGreeting.defaultProps = {\n  name: 'Stranger'\n};\n\n// 渲染出 \"Hello, Stranger\"：\nReactDOM.render(\n  <Greeting />,\n  document.getElementById('example')\n);\n```\n\n如果你正在使用像 [transform-class-properties](https://babeljs.io/docs/plugins/transform-class-properties/) 的 Babel 转换工具，你也可以在 React 组件类中声明 `defaultProps` 作为静态属性。此语法提案还没有最终确定，需要进行编译后才能在浏览器中运行。要了解更多信息，请查阅 [class fields proposal](https://github.com/tc39/proposal-class-fields)。\n\n```\nclass Greeting extends React.Component {\n  static defaultProps = {\n    name: 'stranger'\n  }\n\n  render() {\n    return (\n      <div>Hello, {this.props.name}</div>\n    )\n  }\n}\n```\n\n`defaultProps` 用于确保 `this.props.name` 在父组件没有\b指定其值时，有一个默认值。`propTypes` 类型检查发生在 `defaultProps` 赋值后，所以类型检查也适用于 `defaultProps`。","slug":"react-14","published":1,"updated":"2020-05-30T06:13:47.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6ay000vxy0i6obc5ybq","content":"<h3 id=\"React中的类型检查：prop-types-包\"><a href=\"#React中的类型检查：prop-types-包\" class=\"headerlink\" title=\"React中的类型检查：prop-types 包\"></a>React中的类型检查：prop-types 包</h3><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>编写组件</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">PropTypes</span> from <span class=\"symbol\">'prop</span>-types';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;h1&gt;<span class=\"type\">Hello</span>, &#123;<span class=\"keyword\">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Greeting</span>.propTypes = &#123;</span><br><span class=\"line\">  name: <span class=\"type\">PropTypes</span>.string</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>PropTypes</code> 提供一系列验证器，可用于确保组件接收到的数据类型是有效的。在本例中, 我们使用了 <code>PropTypes.string</code>。当传入的 <code>prop</code> 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，<code>propTypes</code> 仅在开发模式下进行检查。</p>\n<p>propTypes提供了使用不同验证器的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.propTypes = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 你可以将属性声明为 JS 原生类型，默认情况下</span></span><br><span class=\"line\">  <span class=\"comment\">// 这些属性都是可选的。</span></span><br><span class=\"line\">  optionalArray: PropTypes.array,</span><br><span class=\"line\">  optionalBool: PropTypes.bool,</span><br><span class=\"line\">  optionalFunc: PropTypes.func,</span><br><span class=\"line\">  optionalNumber: PropTypes.number,</span><br><span class=\"line\">  optionalObject: PropTypes.object,</span><br><span class=\"line\">  optionalString: PropTypes.string,</span><br><span class=\"line\">  optionalSymbol: PropTypes.symbol,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span></span><br><span class=\"line\">  <span class=\"comment\">// (或 Fragment) 也包含这些类型。</span></span><br><span class=\"line\">  optionalNode: PropTypes.node,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个 React 元素。</span></span><br><span class=\"line\">  optionalElement: PropTypes.element,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个 React 元素类型（即，MyComponent）。</span></span><br><span class=\"line\">  optionalElementType: PropTypes.elementType,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你也可以声明 prop 为类的实例，这里使用</span></span><br><span class=\"line\">  <span class=\"comment\">// JS 的 instanceof 操作符。</span></span><br><span class=\"line\">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你可以让你的 prop 只能是特定的值，指定它为</span></span><br><span class=\"line\">  <span class=\"comment\">// 枚举类型。</span></span><br><span class=\"line\">  optionalEnum: PropTypes.oneOf([<span class=\"string\">'News'</span>, <span class=\"string\">'Photos'</span>]),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个对象可以是几种类型中的任意一个类型</span></span><br><span class=\"line\">  optionalUnion: PropTypes.oneOfType([</span><br><span class=\"line\">    PropTypes.string,</span><br><span class=\"line\">    PropTypes.number,</span><br><span class=\"line\">    PropTypes.instanceOf(Message)</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可以指定一个数组由某一类型的元素组成</span></span><br><span class=\"line\">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可以指定一个对象由某一类型的值组成</span></span><br><span class=\"line\">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可以指定一个对象由特定的类型值组成</span></span><br><span class=\"line\">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class=\"line\">    color: PropTypes.string,</span><br><span class=\"line\">    fontSize: PropTypes.number</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// An object with warnings on extra properties</span></span><br><span class=\"line\">  optionalObjectWithStrictShape: PropTypes.exact(&#123;</span><br><span class=\"line\">    name: PropTypes.string,</span><br><span class=\"line\">    quantity: PropTypes.number</span><br><span class=\"line\">  &#125;),   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span></span><br><span class=\"line\">  <span class=\"comment\">// 这个 prop 没有被提供时，会打印警告信息。</span></span><br><span class=\"line\">  requiredFunc: PropTypes.func.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 任意类型的数据</span></span><br><span class=\"line\">  requiredAny: PropTypes.any.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span></span><br><span class=\"line\">  <span class=\"comment\">// 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。</span></span><br><span class=\"line\">  customProp: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">props, propName, componentName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"regexp\">/matchme/</span>.test(props[propName])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'Invalid prop `'</span> + propName + <span class=\"string\">'` supplied to'</span> +</span><br><span class=\"line\">        <span class=\"string\">' `'</span> + componentName + <span class=\"string\">'`. Validation failed.'</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span></span><br><span class=\"line\">  <span class=\"comment\">// 它应该在验证失败时返回一个 Error 对象。</span></span><br><span class=\"line\">  <span class=\"comment\">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span></span><br><span class=\"line\">  <span class=\"comment\">// 第一个是数组或对象本身</span></span><br><span class=\"line\">  <span class=\"comment\">// 第二个是他们当前的键。</span></span><br><span class=\"line\">  customArrayProp: PropTypes.arrayOf(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">propValue, key, componentName, location, propFullName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"regexp\">/matchme/</span>.test(propValue[key])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'Invalid prop `'</span> + propFullName + <span class=\"string\">'` supplied to'</span> +</span><br><span class=\"line\">        <span class=\"string\">' `'</span> + componentName + <span class=\"string\">'`. Validation failed.'</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>限制单个元素</p>\n<p>可以通过PropsTypes.element来确保传递组件的children中只包含一个元素。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">PropTypes</span> from <span class=\"symbol\">'prop</span>-types';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这必须只有一个元素，否则控制台会打印警告。</span></span><br><span class=\"line\">    const children = <span class=\"keyword\">this</span>.props.children;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;children&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">MyComponent</span>.propTypes = &#123;</span><br><span class=\"line\">  children: <span class=\"type\">PropTypes</span>.element.isRequired</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认prop值\"><a href=\"#默认prop值\" class=\"headerlink\" title=\"默认prop值\"></a>默认prop值</h3><p>您可以通过配置特定的 <code>defaultProps</code> 属性来定义 <code>props</code> 的默认值：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;h1&gt;<span class=\"type\">Hello</span>, &#123;<span class=\"keyword\">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定 props 的默认值：</span></span><br><span class=\"line\"><span class=\"type\">Greeting</span>.defaultProps = &#123;</span><br><span class=\"line\">  name: <span class=\"symbol\">'Strange</span>r'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 渲染出 \"Hello, Stranger\"：</span></span><br><span class=\"line\"><span class=\"type\">ReactDOM</span>.render(</span><br><span class=\"line\">  &lt;<span class=\"type\">Greeting</span> /&gt;,</span><br><span class=\"line\">  document.getElementById(<span class=\"symbol\">'exampl</span>e')</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>如果你正在使用像 <a href=\"https://babeljs.io/docs/plugins/transform-class-properties/\" target=\"_blank\" rel=\"noopener\">transform-class-properties</a> 的 Babel 转换工具，你也可以在 React 组件类中声明 <code>defaultProps</code> 作为静态属性。此语法提案还没有最终确定，需要进行编译后才能在浏览器中运行。要了解更多信息，请查阅 <a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"noopener\">class fields proposal</a>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  static defaultProps = &#123;</span><br><span class=\"line\">    name: <span class=\"symbol\">'strange</span>r'</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;<span class=\"type\">Hello</span>, &#123;<span class=\"keyword\">this</span>.props.name&#125;&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>defaultProps</code> 用于确保 <code>this.props.name</code> 在父组件没有\b指定其值时，有一个默认值。<code>propTypes</code> 类型检查发生在 <code>defaultProps</code> 赋值后，所以类型检查也适用于 <code>defaultProps</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"React中的类型检查：prop-types-包\"><a href=\"#React中的类型检查：prop-types-包\" class=\"headerlink\" title=\"React中的类型检查：prop-types 包\"></a>React中的类型检查：prop-types 包</h3><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>编写组件</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">PropTypes</span> from <span class=\"symbol\">'prop</span>-types';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;h1&gt;<span class=\"type\">Hello</span>, &#123;<span class=\"keyword\">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Greeting</span>.propTypes = &#123;</span><br><span class=\"line\">  name: <span class=\"type\">PropTypes</span>.string</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>PropTypes</code> 提供一系列验证器，可用于确保组件接收到的数据类型是有效的。在本例中, 我们使用了 <code>PropTypes.string</code>。当传入的 <code>prop</code> 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，<code>propTypes</code> 仅在开发模式下进行检查。</p>\n<p>propTypes提供了使用不同验证器的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> PropTypes <span class=\"keyword\">from</span> <span class=\"string\">'prop-types'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MyComponent.propTypes = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 你可以将属性声明为 JS 原生类型，默认情况下</span></span><br><span class=\"line\">  <span class=\"comment\">// 这些属性都是可选的。</span></span><br><span class=\"line\">  optionalArray: PropTypes.array,</span><br><span class=\"line\">  optionalBool: PropTypes.bool,</span><br><span class=\"line\">  optionalFunc: PropTypes.func,</span><br><span class=\"line\">  optionalNumber: PropTypes.number,</span><br><span class=\"line\">  optionalObject: PropTypes.object,</span><br><span class=\"line\">  optionalString: PropTypes.string,</span><br><span class=\"line\">  optionalSymbol: PropTypes.symbol,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span></span><br><span class=\"line\">  <span class=\"comment\">// (或 Fragment) 也包含这些类型。</span></span><br><span class=\"line\">  optionalNode: PropTypes.node,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个 React 元素。</span></span><br><span class=\"line\">  optionalElement: PropTypes.element,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个 React 元素类型（即，MyComponent）。</span></span><br><span class=\"line\">  optionalElementType: PropTypes.elementType,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你也可以声明 prop 为类的实例，这里使用</span></span><br><span class=\"line\">  <span class=\"comment\">// JS 的 instanceof 操作符。</span></span><br><span class=\"line\">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你可以让你的 prop 只能是特定的值，指定它为</span></span><br><span class=\"line\">  <span class=\"comment\">// 枚举类型。</span></span><br><span class=\"line\">  optionalEnum: PropTypes.oneOf([<span class=\"string\">'News'</span>, <span class=\"string\">'Photos'</span>]),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 一个对象可以是几种类型中的任意一个类型</span></span><br><span class=\"line\">  optionalUnion: PropTypes.oneOfType([</span><br><span class=\"line\">    PropTypes.string,</span><br><span class=\"line\">    PropTypes.number,</span><br><span class=\"line\">    PropTypes.instanceOf(Message)</span><br><span class=\"line\">  ]),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可以指定一个数组由某一类型的元素组成</span></span><br><span class=\"line\">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可以指定一个对象由某一类型的值组成</span></span><br><span class=\"line\">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可以指定一个对象由特定的类型值组成</span></span><br><span class=\"line\">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class=\"line\">    color: PropTypes.string,</span><br><span class=\"line\">    fontSize: PropTypes.number</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// An object with warnings on extra properties</span></span><br><span class=\"line\">  optionalObjectWithStrictShape: PropTypes.exact(&#123;</span><br><span class=\"line\">    name: PropTypes.string,</span><br><span class=\"line\">    quantity: PropTypes.number</span><br><span class=\"line\">  &#125;),   </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span></span><br><span class=\"line\">  <span class=\"comment\">// 这个 prop 没有被提供时，会打印警告信息。</span></span><br><span class=\"line\">  requiredFunc: PropTypes.func.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 任意类型的数据</span></span><br><span class=\"line\">  requiredAny: PropTypes.any.isRequired,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span></span><br><span class=\"line\">  <span class=\"comment\">// 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。</span></span><br><span class=\"line\">  customProp: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">props, propName, componentName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"regexp\">/matchme/</span>.test(props[propName])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'Invalid prop `'</span> + propName + <span class=\"string\">'` supplied to'</span> +</span><br><span class=\"line\">        <span class=\"string\">' `'</span> + componentName + <span class=\"string\">'`. Validation failed.'</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span></span><br><span class=\"line\">  <span class=\"comment\">// 它应该在验证失败时返回一个 Error 对象。</span></span><br><span class=\"line\">  <span class=\"comment\">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span></span><br><span class=\"line\">  <span class=\"comment\">// 第一个是数组或对象本身</span></span><br><span class=\"line\">  <span class=\"comment\">// 第二个是他们当前的键。</span></span><br><span class=\"line\">  customArrayProp: PropTypes.arrayOf(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">propValue, key, componentName, location, propFullName</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"regexp\">/matchme/</span>.test(propValue[key])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'Invalid prop `'</span> + propFullName + <span class=\"string\">'` supplied to'</span> +</span><br><span class=\"line\">        <span class=\"string\">' `'</span> + componentName + <span class=\"string\">'`. Validation failed.'</span></span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>限制单个元素</p>\n<p>可以通过PropsTypes.element来确保传递组件的children中只包含一个元素。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"type\">PropTypes</span> from <span class=\"symbol\">'prop</span>-types';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这必须只有一个元素，否则控制台会打印警告。</span></span><br><span class=\"line\">    const children = <span class=\"keyword\">this</span>.props.children;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;children&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">MyComponent</span>.propTypes = &#123;</span><br><span class=\"line\">  children: <span class=\"type\">PropTypes</span>.element.isRequired</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认prop值\"><a href=\"#默认prop值\" class=\"headerlink\" title=\"默认prop值\"></a>默认prop值</h3><p>您可以通过配置特定的 <code>defaultProps</code> 属性来定义 <code>props</code> 的默认值：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;h1&gt;<span class=\"type\">Hello</span>, &#123;<span class=\"keyword\">this</span>.props.name&#125;&lt;/h1&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定 props 的默认值：</span></span><br><span class=\"line\"><span class=\"type\">Greeting</span>.defaultProps = &#123;</span><br><span class=\"line\">  name: <span class=\"symbol\">'Strange</span>r'</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 渲染出 \"Hello, Stranger\"：</span></span><br><span class=\"line\"><span class=\"type\">ReactDOM</span>.render(</span><br><span class=\"line\">  &lt;<span class=\"type\">Greeting</span> /&gt;,</span><br><span class=\"line\">  document.getElementById(<span class=\"symbol\">'exampl</span>e')</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>如果你正在使用像 <a href=\"https://babeljs.io/docs/plugins/transform-class-properties/\" target=\"_blank\" rel=\"noopener\">transform-class-properties</a> 的 Babel 转换工具，你也可以在 React 组件类中声明 <code>defaultProps</code> 作为静态属性。此语法提案还没有最终确定，需要进行编译后才能在浏览器中运行。要了解更多信息，请查阅 <a href=\"https://github.com/tc39/proposal-class-fields\" target=\"_blank\" rel=\"noopener\">class fields proposal</a>。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeting</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  static defaultProps = &#123;</span><br><span class=\"line\">    name: <span class=\"symbol\">'strange</span>r'</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;<span class=\"type\">Hello</span>, &#123;<span class=\"keyword\">this</span>.props.name&#125;&lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>defaultProps</code> 用于确保 <code>this.props.name</code> 在父组件没有\b指定其值时，有一个默认值。<code>propTypes</code> 类型检查发生在 <code>defaultProps</code> 赋值后，所以类型检查也适用于 <code>defaultProps</code>。</p>\n"},{"title":"React高级——ref的使用方法","date":"2020-06-01T08:40:09.000Z","_content":"\n在react典型的数据流中，`props`传递是父子组件交互的唯一方式；通过传递一个新的`props`值来使子组件重新`re-render`,从而达到父子组件通信。当然，就像react官网所描述的一样，在react典型的数据量之外，某些情况下（例如和第三方的dom库整合，或者某个dom元素focus等）为了修改子组件我们可能需要另一种方式，这就是`ref`方式。\n\n### ref简介\n\nReact提供的这个`ref`属性，**表示为对组件真正实例的引用，其实就是`ReactDOM.render()返回的组件实例`**；需要区分一下，`ReactDOM.render()`渲染组件时返回的是组件实例；而渲染dom元素时，返回是具体的dom节点。\n\n`ref`可以挂到任何组件上，可以挂到组件上也可以是dom元素上；\n\n> 挂到组件（这里组件指的是有状态组件）上的ref表示对组件实例的引用，而挂载到dom元素上时表示具体的dom元素节点。\n\n### ref可以设置回调函数\n\nref属性可以设置为一个回调函数，这也是官方强烈推荐的用法；这个函数执行的时机为：\n\n- `组件被挂载后`，回调函数被立即执行，回调函数的参数为该组件的具体实例。\n- `组件被卸载或者原有的ref属性本身发生变化时`，回调也会被立即执行，此时回调函数参数为`null`，以确保内存泄露。\n\n例如下面代码：\n\n```\nRegisterStepTwo = React.createClass({\n        getInitialState(){\n          return {visible: true};\n        },\n      changeVisible(){\n        this.setState({visible: !this.state.visible});\n      },\n      refCb(instance){\n        console.log(instance);\n      },\n      render(){\n        return(\n          <div>\n            <button type=\"button\" onClick={this.changeVisible}>{this.state.visible ? '卸载' : '挂载'}ConfirmPass\n            </button>\n            {\n              this.state.visible ?\n                <ConfirmPass ref={this.refCb} onChange={this.handleChange}/>: null\n             }\n           </div>\n         )\n      }\n    });\n```\n\n上述代码，渲染到页面时可以发现console.log出对应的组件实例，切换按钮时，`ConfirmPass`也在挂载与卸载之间切换，所以能看到不同的console.log结果。\n\n### ref可以设置字符串\n\nref还可以设置为字符串值，而不是回调函数；这种方式基本不推荐使用，或者在未来的react版本中不会再支持该方式，但是可以了解一下。\n\n例如下面`input`设置ref的值为字符串。\n\n```\n<input ref=\"input\" />\n```\n\n然后在其他地方如事件回调中通过`this.refs.input`可以访问到该组件实例，其实就是dom元素节点。\n\n```\nlet inputEl = this.refs.input;\n//然后通过inputEl来完成后续的逻辑，如focus、获取其值等等\n```\n\n### 获取ref引用组件对应的dom节点\n\n不管ref设置值是回调函数还是字符串，都可以通过`ReactDOM.findDOMNode(ref)`来获取组件挂载后真正的dom节点。\n\n但是对于html元素使用ref的情况，ref本身引用的就是该元素的实际dom节点，无需使用`ReactDOM.findDOMNode(ref)`来获取，该方法常用于React组件上的ref。\n\n### ref在有状态组件中的使用\n\n上文说到过`ref`用到react有状态组件时，ref引用的是组件的实例；所以可以通过子组件的`ref`可以访问到子组件实例的`props`、`state`、`refs`、实例方法(非继承而来的方法)等等。\n\n### ref在无状态组件中的使用\n\n无法通过`ref`来获取无状态组件实例。\n\n另外，对于无状态组件我们想访问的无非是其中包含的组件或者dom元素，我们可以通过一个变量来保存我们想要的组件或者dom元素组件的实例引用。例如下面代码：\n\ncopy\n\n```\nfunction TestComp(props){\n    let refDom;\n    return (<div>\n        <div ref={(node) => refDom = node}>\n            ...\n        </div>\n    </div>)\n}\n```\n\n \n\n这样，可以通过变量`refDom`来访问到无状态组件中的指定dom元素了，访问其中的其他组件实例类似。\n\n### ref在HOC中存在问题\n\nreact的`HOC`是高阶组件，简单理解就是包装了一个低阶的组件，最后返回一个高阶的组件；高阶组件其实是在低阶组件基础上做了一些事情，比方说[`antd`](https://ant.design/docs/react/introduce-cn)组件的`Form create`的方法，它就是在为低阶组件封装了一些特殊的属性，比如`form`属性。\n\n既然`HOC`会基于低阶组件生成一个新的高阶组件，若用`ref`就不能访问到我们真正需要的低阶组件实例，我们访问到的其实是高阶组件实例。所以:\n\n> 若HOC不做特殊处理，ref是无法访问到低阶组件实例的\n\n要想用`ref`访问低阶组件实例，就必须得HOC支持，就像`Redux`的connect方法提供的`withRef`属性来访问低阶组件一样。具体可以参考[这里](https://segmentfault.com/a/1190000008112017#articleHeader12)。\n\n### 总结\n\n`ref`提供了一种对于react标准的数据流不太适用的情况下组件间交互的方式，例如管理dom元素focus、text selection以及与第三方的dom库整合等等。 但是在大多数情况下应该使用react响应数据流那种方式，不要过度使用ref。\n\n另外，在使用ref时，不用担心会导致内存泄露的问题，react会自动帮你管理好，在组件卸载时ref值也会被销毁。\n\n最后补充一点：\n\n> 不要在组件的`render`方法中访问`ref`引用，`render`方法只是返回一个虚拟dom，这时组件不一定挂载到dom中或者render返回的虚拟dom不一定会更新到dom中。","source":"_posts/react-15.md","raw":"---\ntitle: React高级——ref的使用方法\ndate: 2020-06-01 16:40:09\ntags:\ncategories: react\n---\n\n在react典型的数据流中，`props`传递是父子组件交互的唯一方式；通过传递一个新的`props`值来使子组件重新`re-render`,从而达到父子组件通信。当然，就像react官网所描述的一样，在react典型的数据量之外，某些情况下（例如和第三方的dom库整合，或者某个dom元素focus等）为了修改子组件我们可能需要另一种方式，这就是`ref`方式。\n\n### ref简介\n\nReact提供的这个`ref`属性，**表示为对组件真正实例的引用，其实就是`ReactDOM.render()返回的组件实例`**；需要区分一下，`ReactDOM.render()`渲染组件时返回的是组件实例；而渲染dom元素时，返回是具体的dom节点。\n\n`ref`可以挂到任何组件上，可以挂到组件上也可以是dom元素上；\n\n> 挂到组件（这里组件指的是有状态组件）上的ref表示对组件实例的引用，而挂载到dom元素上时表示具体的dom元素节点。\n\n### ref可以设置回调函数\n\nref属性可以设置为一个回调函数，这也是官方强烈推荐的用法；这个函数执行的时机为：\n\n- `组件被挂载后`，回调函数被立即执行，回调函数的参数为该组件的具体实例。\n- `组件被卸载或者原有的ref属性本身发生变化时`，回调也会被立即执行，此时回调函数参数为`null`，以确保内存泄露。\n\n例如下面代码：\n\n```\nRegisterStepTwo = React.createClass({\n        getInitialState(){\n          return {visible: true};\n        },\n      changeVisible(){\n        this.setState({visible: !this.state.visible});\n      },\n      refCb(instance){\n        console.log(instance);\n      },\n      render(){\n        return(\n          <div>\n            <button type=\"button\" onClick={this.changeVisible}>{this.state.visible ? '卸载' : '挂载'}ConfirmPass\n            </button>\n            {\n              this.state.visible ?\n                <ConfirmPass ref={this.refCb} onChange={this.handleChange}/>: null\n             }\n           </div>\n         )\n      }\n    });\n```\n\n上述代码，渲染到页面时可以发现console.log出对应的组件实例，切换按钮时，`ConfirmPass`也在挂载与卸载之间切换，所以能看到不同的console.log结果。\n\n### ref可以设置字符串\n\nref还可以设置为字符串值，而不是回调函数；这种方式基本不推荐使用，或者在未来的react版本中不会再支持该方式，但是可以了解一下。\n\n例如下面`input`设置ref的值为字符串。\n\n```\n<input ref=\"input\" />\n```\n\n然后在其他地方如事件回调中通过`this.refs.input`可以访问到该组件实例，其实就是dom元素节点。\n\n```\nlet inputEl = this.refs.input;\n//然后通过inputEl来完成后续的逻辑，如focus、获取其值等等\n```\n\n### 获取ref引用组件对应的dom节点\n\n不管ref设置值是回调函数还是字符串，都可以通过`ReactDOM.findDOMNode(ref)`来获取组件挂载后真正的dom节点。\n\n但是对于html元素使用ref的情况，ref本身引用的就是该元素的实际dom节点，无需使用`ReactDOM.findDOMNode(ref)`来获取，该方法常用于React组件上的ref。\n\n### ref在有状态组件中的使用\n\n上文说到过`ref`用到react有状态组件时，ref引用的是组件的实例；所以可以通过子组件的`ref`可以访问到子组件实例的`props`、`state`、`refs`、实例方法(非继承而来的方法)等等。\n\n### ref在无状态组件中的使用\n\n无法通过`ref`来获取无状态组件实例。\n\n另外，对于无状态组件我们想访问的无非是其中包含的组件或者dom元素，我们可以通过一个变量来保存我们想要的组件或者dom元素组件的实例引用。例如下面代码：\n\ncopy\n\n```\nfunction TestComp(props){\n    let refDom;\n    return (<div>\n        <div ref={(node) => refDom = node}>\n            ...\n        </div>\n    </div>)\n}\n```\n\n \n\n这样，可以通过变量`refDom`来访问到无状态组件中的指定dom元素了，访问其中的其他组件实例类似。\n\n### ref在HOC中存在问题\n\nreact的`HOC`是高阶组件，简单理解就是包装了一个低阶的组件，最后返回一个高阶的组件；高阶组件其实是在低阶组件基础上做了一些事情，比方说[`antd`](https://ant.design/docs/react/introduce-cn)组件的`Form create`的方法，它就是在为低阶组件封装了一些特殊的属性，比如`form`属性。\n\n既然`HOC`会基于低阶组件生成一个新的高阶组件，若用`ref`就不能访问到我们真正需要的低阶组件实例，我们访问到的其实是高阶组件实例。所以:\n\n> 若HOC不做特殊处理，ref是无法访问到低阶组件实例的\n\n要想用`ref`访问低阶组件实例，就必须得HOC支持，就像`Redux`的connect方法提供的`withRef`属性来访问低阶组件一样。具体可以参考[这里](https://segmentfault.com/a/1190000008112017#articleHeader12)。\n\n### 总结\n\n`ref`提供了一种对于react标准的数据流不太适用的情况下组件间交互的方式，例如管理dom元素focus、text selection以及与第三方的dom库整合等等。 但是在大多数情况下应该使用react响应数据流那种方式，不要过度使用ref。\n\n另外，在使用ref时，不用担心会导致内存泄露的问题，react会自动帮你管理好，在组件卸载时ref值也会被销毁。\n\n最后补充一点：\n\n> 不要在组件的`render`方法中访问`ref`引用，`render`方法只是返回一个虚拟dom，这时组件不一定挂载到dom中或者render返回的虚拟dom不一定会更新到dom中。","slug":"react-15","published":1,"updated":"2020-06-01T09:02:27.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbyuj6az000xxy0igalu32w6","content":"<p>在react典型的数据流中，<code>props</code>传递是父子组件交互的唯一方式；通过传递一个新的<code>props</code>值来使子组件重新<code>re-render</code>,从而达到父子组件通信。当然，就像react官网所描述的一样，在react典型的数据量之外，某些情况下（例如和第三方的dom库整合，或者某个dom元素focus等）为了修改子组件我们可能需要另一种方式，这就是<code>ref</code>方式。</p>\n<h3 id=\"ref简介\"><a href=\"#ref简介\" class=\"headerlink\" title=\"ref简介\"></a>ref简介</h3><p>React提供的这个<code>ref</code>属性，<strong>表示为对组件真正实例的引用，其实就是<code>ReactDOM.render()返回的组件实例</code></strong>；需要区分一下，<code>ReactDOM.render()</code>渲染组件时返回的是组件实例；而渲染dom元素时，返回是具体的dom节点。</p>\n<p><code>ref</code>可以挂到任何组件上，可以挂到组件上也可以是dom元素上；</p>\n<blockquote>\n<p>挂到组件（这里组件指的是有状态组件）上的ref表示对组件实例的引用，而挂载到dom元素上时表示具体的dom元素节点。</p>\n</blockquote>\n<h3 id=\"ref可以设置回调函数\"><a href=\"#ref可以设置回调函数\" class=\"headerlink\" title=\"ref可以设置回调函数\"></a>ref可以设置回调函数</h3><p>ref属性可以设置为一个回调函数，这也是官方强烈推荐的用法；这个函数执行的时机为：</p>\n<ul>\n<li><code>组件被挂载后</code>，回调函数被立即执行，回调函数的参数为该组件的具体实例。</li>\n<li><code>组件被卸载或者原有的ref属性本身发生变化时</code>，回调也会被立即执行，此时回调函数参数为<code>null</code>，以确保内存泄露。</li>\n</ul>\n<p>例如下面代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RegisterStepTwo = React.createClass(&#123;</span><br><span class=\"line\">        getInitialState()&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> &#123;visible: <span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      changeVisible()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;visible: !<span class=\"keyword\">this</span>.state.visible&#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      refCb(instance)&#123;</span><br><span class=\"line\">        console.log(instance);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">            &lt;button type=<span class=\"string\">\"button\"</span> onClick=&#123;<span class=\"keyword\">this</span>.changeVisible&#125;&gt;&#123;<span class=\"keyword\">this</span>.state.visible ? <span class=\"string\">'卸载'</span> : <span class=\"string\">'挂载'</span>&#125;ConfirmPass</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"keyword\">this</span>.state.visible ?</span><br><span class=\"line\">                &lt;ConfirmPass ref=&#123;<span class=\"keyword\">this</span>.refCb&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;/&gt;: <span class=\"literal\">null</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &lt;/div&gt;</span><br><span class=\"line\">         )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，渲染到页面时可以发现console.log出对应的组件实例，切换按钮时，<code>ConfirmPass</code>也在挂载与卸载之间切换，所以能看到不同的console.log结果。</p>\n<h3 id=\"ref可以设置字符串\"><a href=\"#ref可以设置字符串\" class=\"headerlink\" title=\"ref可以设置字符串\"></a>ref可以设置字符串</h3><p>ref还可以设置为字符串值，而不是回调函数；这种方式基本不推荐使用，或者在未来的react版本中不会再支持该方式，但是可以了解一下。</p>\n<p>例如下面<code>input</code>设置ref的值为字符串。</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">input</span> <span class=\"keyword\">ref</span>=\"input\" /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后在其他地方如事件回调中通过<code>this.refs.input</code>可以访问到该组件实例，其实就是dom元素节点。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let inputEl = <span class=\"keyword\">this</span>.<span class=\"built_in\">ref</span>s.input;</span><br><span class=\"line\"><span class=\"comment\">//然后通过inputEl来完成后续的逻辑，如focus、获取其值等等</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取ref引用组件对应的dom节点\"><a href=\"#获取ref引用组件对应的dom节点\" class=\"headerlink\" title=\"获取ref引用组件对应的dom节点\"></a>获取ref引用组件对应的dom节点</h3><p>不管ref设置值是回调函数还是字符串，都可以通过<code>ReactDOM.findDOMNode(ref)</code>来获取组件挂载后真正的dom节点。</p>\n<p>但是对于html元素使用ref的情况，ref本身引用的就是该元素的实际dom节点，无需使用<code>ReactDOM.findDOMNode(ref)</code>来获取，该方法常用于React组件上的ref。</p>\n<h3 id=\"ref在有状态组件中的使用\"><a href=\"#ref在有状态组件中的使用\" class=\"headerlink\" title=\"ref在有状态组件中的使用\"></a>ref在有状态组件中的使用</h3><p>上文说到过<code>ref</code>用到react有状态组件时，ref引用的是组件的实例；所以可以通过子组件的<code>ref</code>可以访问到子组件实例的<code>props</code>、<code>state</code>、<code>refs</code>、实例方法(非继承而来的方法)等等。</p>\n<h3 id=\"ref在无状态组件中的使用\"><a href=\"#ref在无状态组件中的使用\" class=\"headerlink\" title=\"ref在无状态组件中的使用\"></a>ref在无状态组件中的使用</h3><p>无法通过<code>ref</code>来获取无状态组件实例。</p>\n<p>另外，对于无状态组件我们想访问的无非是其中包含的组件或者dom元素，我们可以通过一个变量来保存我们想要的组件或者dom元素组件的实例引用。例如下面代码：</p>\n<p>copy</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TestComp</span>(<span class=\"params\">props</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> refDom;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        &lt;div ref=&#123;(node) =&gt; refDom = node&#125;&gt;</span><br><span class=\"line\">            ...</span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这样，可以通过变量<code>refDom</code>来访问到无状态组件中的指定dom元素了，访问其中的其他组件实例类似。</p>\n<h3 id=\"ref在HOC中存在问题\"><a href=\"#ref在HOC中存在问题\" class=\"headerlink\" title=\"ref在HOC中存在问题\"></a>ref在HOC中存在问题</h3><p>react的<code>HOC</code>是高阶组件，简单理解就是包装了一个低阶的组件，最后返回一个高阶的组件；高阶组件其实是在低阶组件基础上做了一些事情，比方说<a href=\"https://ant.design/docs/react/introduce-cn\" target=\"_blank\" rel=\"noopener\"><code>antd</code></a>组件的<code>Form create</code>的方法，它就是在为低阶组件封装了一些特殊的属性，比如<code>form</code>属性。</p>\n<p>既然<code>HOC</code>会基于低阶组件生成一个新的高阶组件，若用<code>ref</code>就不能访问到我们真正需要的低阶组件实例，我们访问到的其实是高阶组件实例。所以:</p>\n<blockquote>\n<p>若HOC不做特殊处理，ref是无法访问到低阶组件实例的</p>\n</blockquote>\n<p>要想用<code>ref</code>访问低阶组件实例，就必须得HOC支持，就像<code>Redux</code>的connect方法提供的<code>withRef</code>属性来访问低阶组件一样。具体可以参考<a href=\"https://segmentfault.com/a/1190000008112017#articleHeader12\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>ref</code>提供了一种对于react标准的数据流不太适用的情况下组件间交互的方式，例如管理dom元素focus、text selection以及与第三方的dom库整合等等。 但是在大多数情况下应该使用react响应数据流那种方式，不要过度使用ref。</p>\n<p>另外，在使用ref时，不用担心会导致内存泄露的问题，react会自动帮你管理好，在组件卸载时ref值也会被销毁。</p>\n<p>最后补充一点：</p>\n<blockquote>\n<p>不要在组件的<code>render</code>方法中访问<code>ref</code>引用，<code>render</code>方法只是返回一个虚拟dom，这时组件不一定挂载到dom中或者render返回的虚拟dom不一定会更新到dom中。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>在react典型的数据流中，<code>props</code>传递是父子组件交互的唯一方式；通过传递一个新的<code>props</code>值来使子组件重新<code>re-render</code>,从而达到父子组件通信。当然，就像react官网所描述的一样，在react典型的数据量之外，某些情况下（例如和第三方的dom库整合，或者某个dom元素focus等）为了修改子组件我们可能需要另一种方式，这就是<code>ref</code>方式。</p>\n<h3 id=\"ref简介\"><a href=\"#ref简介\" class=\"headerlink\" title=\"ref简介\"></a>ref简介</h3><p>React提供的这个<code>ref</code>属性，<strong>表示为对组件真正实例的引用，其实就是<code>ReactDOM.render()返回的组件实例</code></strong>；需要区分一下，<code>ReactDOM.render()</code>渲染组件时返回的是组件实例；而渲染dom元素时，返回是具体的dom节点。</p>\n<p><code>ref</code>可以挂到任何组件上，可以挂到组件上也可以是dom元素上；</p>\n<blockquote>\n<p>挂到组件（这里组件指的是有状态组件）上的ref表示对组件实例的引用，而挂载到dom元素上时表示具体的dom元素节点。</p>\n</blockquote>\n<h3 id=\"ref可以设置回调函数\"><a href=\"#ref可以设置回调函数\" class=\"headerlink\" title=\"ref可以设置回调函数\"></a>ref可以设置回调函数</h3><p>ref属性可以设置为一个回调函数，这也是官方强烈推荐的用法；这个函数执行的时机为：</p>\n<ul>\n<li><code>组件被挂载后</code>，回调函数被立即执行，回调函数的参数为该组件的具体实例。</li>\n<li><code>组件被卸载或者原有的ref属性本身发生变化时</code>，回调也会被立即执行，此时回调函数参数为<code>null</code>，以确保内存泄露。</li>\n</ul>\n<p>例如下面代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RegisterStepTwo = React.createClass(&#123;</span><br><span class=\"line\">        getInitialState()&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> &#123;visible: <span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      changeVisible()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;visible: !<span class=\"keyword\">this</span>.state.visible&#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      refCb(instance)&#123;</span><br><span class=\"line\">        console.log(instance);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      render()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>(</span><br><span class=\"line\">          &lt;div&gt;</span><br><span class=\"line\">            &lt;button type=<span class=\"string\">\"button\"</span> onClick=&#123;<span class=\"keyword\">this</span>.changeVisible&#125;&gt;&#123;<span class=\"keyword\">this</span>.state.visible ? <span class=\"string\">'卸载'</span> : <span class=\"string\">'挂载'</span>&#125;ConfirmPass</span><br><span class=\"line\">            &lt;/button&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"keyword\">this</span>.state.visible ?</span><br><span class=\"line\">                &lt;ConfirmPass ref=&#123;<span class=\"keyword\">this</span>.refCb&#125; onChange=&#123;<span class=\"keyword\">this</span>.handleChange&#125;/&gt;: <span class=\"literal\">null</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &lt;/div&gt;</span><br><span class=\"line\">         )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，渲染到页面时可以发现console.log出对应的组件实例，切换按钮时，<code>ConfirmPass</code>也在挂载与卸载之间切换，所以能看到不同的console.log结果。</p>\n<h3 id=\"ref可以设置字符串\"><a href=\"#ref可以设置字符串\" class=\"headerlink\" title=\"ref可以设置字符串\"></a>ref可以设置字符串</h3><p>ref还可以设置为字符串值，而不是回调函数；这种方式基本不推荐使用，或者在未来的react版本中不会再支持该方式，但是可以了解一下。</p>\n<p>例如下面<code>input</code>设置ref的值为字符串。</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">input</span> <span class=\"keyword\">ref</span>=\"input\" /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后在其他地方如事件回调中通过<code>this.refs.input</code>可以访问到该组件实例，其实就是dom元素节点。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let inputEl = <span class=\"keyword\">this</span>.<span class=\"built_in\">ref</span>s.input;</span><br><span class=\"line\"><span class=\"comment\">//然后通过inputEl来完成后续的逻辑，如focus、获取其值等等</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取ref引用组件对应的dom节点\"><a href=\"#获取ref引用组件对应的dom节点\" class=\"headerlink\" title=\"获取ref引用组件对应的dom节点\"></a>获取ref引用组件对应的dom节点</h3><p>不管ref设置值是回调函数还是字符串，都可以通过<code>ReactDOM.findDOMNode(ref)</code>来获取组件挂载后真正的dom节点。</p>\n<p>但是对于html元素使用ref的情况，ref本身引用的就是该元素的实际dom节点，无需使用<code>ReactDOM.findDOMNode(ref)</code>来获取，该方法常用于React组件上的ref。</p>\n<h3 id=\"ref在有状态组件中的使用\"><a href=\"#ref在有状态组件中的使用\" class=\"headerlink\" title=\"ref在有状态组件中的使用\"></a>ref在有状态组件中的使用</h3><p>上文说到过<code>ref</code>用到react有状态组件时，ref引用的是组件的实例；所以可以通过子组件的<code>ref</code>可以访问到子组件实例的<code>props</code>、<code>state</code>、<code>refs</code>、实例方法(非继承而来的方法)等等。</p>\n<h3 id=\"ref在无状态组件中的使用\"><a href=\"#ref在无状态组件中的使用\" class=\"headerlink\" title=\"ref在无状态组件中的使用\"></a>ref在无状态组件中的使用</h3><p>无法通过<code>ref</code>来获取无状态组件实例。</p>\n<p>另外，对于无状态组件我们想访问的无非是其中包含的组件或者dom元素，我们可以通过一个变量来保存我们想要的组件或者dom元素组件的实例引用。例如下面代码：</p>\n<p>copy</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">TestComp</span>(<span class=\"params\">props</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> refDom;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        &lt;div ref=&#123;(node) =&gt; refDom = node&#125;&gt;</span><br><span class=\"line\">            ...</span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这样，可以通过变量<code>refDom</code>来访问到无状态组件中的指定dom元素了，访问其中的其他组件实例类似。</p>\n<h3 id=\"ref在HOC中存在问题\"><a href=\"#ref在HOC中存在问题\" class=\"headerlink\" title=\"ref在HOC中存在问题\"></a>ref在HOC中存在问题</h3><p>react的<code>HOC</code>是高阶组件，简单理解就是包装了一个低阶的组件，最后返回一个高阶的组件；高阶组件其实是在低阶组件基础上做了一些事情，比方说<a href=\"https://ant.design/docs/react/introduce-cn\" target=\"_blank\" rel=\"noopener\"><code>antd</code></a>组件的<code>Form create</code>的方法，它就是在为低阶组件封装了一些特殊的属性，比如<code>form</code>属性。</p>\n<p>既然<code>HOC</code>会基于低阶组件生成一个新的高阶组件，若用<code>ref</code>就不能访问到我们真正需要的低阶组件实例，我们访问到的其实是高阶组件实例。所以:</p>\n<blockquote>\n<p>若HOC不做特殊处理，ref是无法访问到低阶组件实例的</p>\n</blockquote>\n<p>要想用<code>ref</code>访问低阶组件实例，就必须得HOC支持，就像<code>Redux</code>的connect方法提供的<code>withRef</code>属性来访问低阶组件一样。具体可以参考<a href=\"https://segmentfault.com/a/1190000008112017#articleHeader12\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>ref</code>提供了一种对于react标准的数据流不太适用的情况下组件间交互的方式，例如管理dom元素focus、text selection以及与第三方的dom库整合等等。 但是在大多数情况下应该使用react响应数据流那种方式，不要过度使用ref。</p>\n<p>另外，在使用ref时，不用担心会导致内存泄露的问题，react会自动帮你管理好，在组件卸载时ref值也会被销毁。</p>\n<p>最后补充一点：</p>\n<blockquote>\n<p>不要在组件的<code>render</code>方法中访问<code>ref</code>引用，<code>render</code>方法只是返回一个虚拟dom，这时组件不一定挂载到dom中或者render返回的虚拟dom不一定会更新到dom中。</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckbyuj6al0006xy0i30a4cqpb","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6aq000bxy0i87ljc5gs"},{"post_id":"ckbyuj6ad0000xy0ic889g4l6","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6ar000exy0i3ynybvlo"},{"post_id":"ckbyuj6am0007xy0i48ah7csd","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6as000gxy0i9orkelmi"},{"post_id":"ckbyuj6ao0009xy0i6sltgka5","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6at000ixy0ifbcmh76z"},{"post_id":"ckbyuj6ah0002xy0i4k0364bf","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6au000kxy0i54mtb311"},{"post_id":"ckbyuj6ap000axy0id7np0yg9","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6av000mxy0ielitdeb0"},{"post_id":"ckbyuj6aq000dxy0i20v9biz3","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6av000oxy0iezeq2pm0"},{"post_id":"ckbyuj6ak0005xy0i56tx88es","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6aw000qxy0ibpeg4ktt"},{"post_id":"ckbyuj6ar000fxy0ihhrre44e","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6ax000sxy0iage6c2f3"},{"post_id":"ckbyuj6as000hxy0ieiah0nze","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6ay000uxy0i79p87pi4"},{"post_id":"ckbyuj6at000jxy0ifde8c8nv","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6ay000wxy0i8oty0a7i"},{"post_id":"ckbyuj6au000lxy0icw7d87us","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6az000yxy0i3aridbko"},{"post_id":"ckbyuj6av000nxy0i8u2hern6","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6az000zxy0idspz5sbi"},{"post_id":"ckbyuj6aw000pxy0i5m7o7oo0","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6az0010xy0ibj8xha4l"},{"post_id":"ckbyuj6aw000rxy0i6jq1ej0s","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6b00011xy0i6zk63erg"},{"post_id":"ckbyuj6ax000txy0icde5h2kh","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6b00012xy0i8xsradvi"},{"post_id":"ckbyuj6ay000vxy0i6obc5ybq","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6b00013xy0i0c297725"},{"post_id":"ckbyuj6az000xxy0igalu32w6","category_id":"ckbyuj6aj0004xy0i7ay5cp99","_id":"ckbyuj6b00014xy0i32i4hhhx"}],"PostTag":[],"Tag":[]}}